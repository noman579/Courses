**Govt. College University, Faisalabad** <br> <br> <br> <br> <br> **(Insert University Logo Here)** <br> <br> <br> <br> <br> **SmartPark: An AI-Powered Autonomous Parking Management System** <br> <br> <br> <br> **Supervised By** Mr. Muhammad Bilal <br> <br> <br> <br> **Submitted By** | Student Name | University Roll No | | :----------- | :----------------- | | Hamid Raza | 685672 | <br> <br> <br> <br> **Department of Computer Science** **Govt. Islamia Graduate College, Faisalabad** <br> <br> **2020-2024** [PAGE BREAK] **CERTIFICATE** <br> <br> This is to certify that **Hamid Raza** bearing registration number **2020-GCUF-058317** has completed the final project titled as **“SmartPark: An AI-Powered Autonomous Parking Management System”** at the department of computer science, Govt. Islamia Graduate College, Faisalabad to fulfill the partial requirement for the degree of BSCS. <br> <br> <br> <br> **Supervisor** Mr. Muhammad Bilal Signature: _________________________ <br> <br> <br> <br> **Internal Panel** Member 1: Mr. Umer Bashir Signature: _________________________ <br> <br> Member 2: Mr. Muhammad Hassan Tariq Signature: _________________________ <br> <br> <br> <br> **Head of Department** Signature: _________________________ Department of Computer Science Govt. Islamia Graduate College Sargodha Road, Faisalabad. <br> <br> <br> <br> ii [PAGE BREAK] **DECLARATION** <br> <br> The Work reported in this project was carried by me under the supervision of **Mr. Muhammad Bilal** at Govt. Islamia Graduate College Faisalabad. I hereby declare that this project and contents of the project are the product of my own work and is not done by any other person. I further declare that this work has not been submitted for an award of any other degree. The institution may act if the information provided is found inaccurate at any stage. <br> <br> <br> <br> <br> <br> Name: Hamid Raza Signature: _________________________ <br> <br> Reg no: 2020-GCUF-058317 <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> iii [PAGE BREAK] **ACKNOWLEDGEMENT** <br> <br> I really feel extremely privileged to take this chance to express my heartiest gratitude and deep sense of in depth to the Head of institution regarding this kind and scholastic guidance eager curiosity and constant encouragement. I am thankful to ALLAH and our respected teacher because my teacher's efforts are so important for me. I was not able to perform this task, and I cannot complete this project without their hard work. Thanks to our family and our teacher for their trust and support. My special and heartly thanks to supervisor Mr. Muhammad, who encouraged and directed me. His challenges brought this work towards completion. It's because of him that I achieved this task, and this project came into existence. <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> iv [PAGE BREAK] **ABSTRACT** The rapid increase in vehicular traffic in urban centers has made efficient parking management a critical challenge. Traditional parking systems, characterized by manual ticketing, queue management, and cash-based payments, are inefficient, labor-intensive, and prone to human error, leading to traffic congestion and a frustrating user experience. This project, **"SmartPark: An AI-Powered Autonomous Parking Management System,"** presents a modern, automated solution to address these market gaps. Leveraging a robust technology stack including the **.NET Framework, C#, and Microsoft SQL Server (MSSQL)**, SmartPark introduces a seamless and autonomous parking experience. The core of the system is its integration with visual cameras and an **Artificial Intelligence (AI) model for Automatic Number Plate Recognition (ANPR)**. Upon a vehicle's arrival, the system captures the number plate, verifies it against the database for pre-booked slots, or assigns a new available slot in real-time. This eliminates the need for manual gatekeepers and physical queues for cars, bikes, and vans. The system features a comprehensive web portal, developed using **HTML, CSS, JavaScript, jQuery, and styled with Bootstrap and Tailwind CSS**, allowing users to register, view parking availability, and pre-book slots for their vehicles. This pre-booking feature guarantees a parking space upon arrival, further enhancing user convenience. For financial transactions, the system integrates the **Stripe payment gateway**, enabling secure and efficient online payments for parking services, thus removing the dependency on physical cash transactions. The checkout process is similarly automated, with ANPR cameras detecting the departing vehicle, de-allocating the slot, and updating the system's availability count instantaneously. By bridging the industry gap with a web-based, AI-driven, and automated solution, SmartPark significantly improves operational efficiency, enhances security, optimizes space utilization, and delivers a superior, hassle-free experience for vehicle owners. <br> <br> <br> v [PAGE BREAK] **Table of Contents** CHAPTER NO 1 INTRODUCTION ..................................................................................... 1 1.1 Introduction to Project ......................................................................................... 2 1.2 Purpose of Project ................................................................................................. 4 1.3 How it Works ........................................................................................................ 6 1.4 Scope of Project ................................................................................................... 8 1.5 Feasibility ............................................................................................................ 10 1.5.1 Technical Feasibility ............................................................................... 10 1.5.2 Economic Feasibility ............................................................................... 12 1.5.3 Operational Feasibility ............................................................................ 14 1.5.4 Legal and Ethical Feasibility ................................................................... 16 1.6 Risk Management ................................................................................................ 18 1.7 Project Planning ................................................................................................. 20 1.8 Project Modules ................................................................................................. 22 CHAPTER NO 2 BACKGROUND AND PROBLEM DEFINITION ................................ 24 2.1 Background Research ......................................................................................... 25 2.2 Existing Technology and Their Limitations ........................................................ 27 2.3 Area of Study ..................................................................................................... 31 2.4 Reason for the Project ........................................................................................ 34 2.5 Objectives of the Project .................................................................................... 36 CHAPTER NO 3 SYSTEM REQUIREMENT ANALYSIS .............................................. 38 3.1 System Fundamental Requirements .................................................................... 39 3.2 System Non-Fundamental Requirements ............................................................ 42 3.2.1 Performance .......................................................................................... 42 3.2.2 Security ................................................................................................. 43 3.2.3 Reliability .............................................................................................. 44 3.2.4 Scalability .............................................................................................. 45 3.2.5 Usability ................................................................................................ 46 3.3 Hardware and Software Requirements ................................................................ 47 3.3.1 Hardware Requirements ........................................................................ 47 3.3.2 Software Requirements .......................................................................... 48 CHAPTER NO 4 SYSTEM DESIGN .................................................................................. 50 4.1 Use Case Diagram ............................................................................................... 51 4.2 Use Cases ........................................................................................................... 53 4.2.1 User Registration ................................................................................... 53 4.2.2 User Login ............................................................................................. 54 4.2.3 Advance Slot Booking ........................................................................... 55 4.2.4 Autonomous Check-in ........................................................................... 56 4.2.5 Autonomous Check-out ......................................................................... 57 4.2.6 Admin Dashboard Access ...................................................................... 58 4.3 System Sequence Diagram ................................................................................. 59 4.4 Class Diagram .................................................................................................... 61 4.5 Data Flow Diagram ............................................................................................ 63 CHAPTER NO 5 IMPLEMENTATION AND TESTING ................................................ 65 5.1 Testing Methods ................................................................................................. 66 5.1.1 Black Box Testing .................................................................................. 66 5.1.2 White Box Testing ................................................................................. 67 5.1.3 Unit Testing ........................................................................................... 68 5.1.4 Integration Testing ................................................................................ 69 5.1.5 System Testing ....................................................................................... 70 5.1.6 Acceptance Testing ............................................................................... 71 5.2 Test Cases .......................................................................................................... 72 5.2.1 Registration Test Cases .......................................................................... 72 5.2.2 Login Test Cases .................................................................................... 74 5.2.3 Slot Booking Test Cases ......................................................................... 76 5.2.4 ANPR Integration Test Cases .................................................................. 78 5.2.5 Payment Gateway Test Cases ................................................................. 80 5.3 User Manual Screenshots (Descriptive) .............................................................. 82 CONCLUSION AND FUTURE WORK ............................................................................. 85 REFERENCES .................................................................................................................... 87 vi [PAGE BREAK] **List of Tables** TABLE 4.1 REGISTRATION USE CASE ............................................................................ 53 TABLE 4.2 LOGIN USE CASE ......................................................................................... 54 TABLE 4.3 ADVANCE SLOT BOOKING USE CASE ......................................................... 55 TABLE 4.4 AUTONOMOUS CHECK-IN USE CASE ........................................................ 56 TABLE 4.5 AUTONOMOUS CHECK-OUT USE CASE ..................................................... 57 TABLE 4.6 ADMIN DASHBOARD ACCESS USE CASE ................................................... 58 TABLE 5.1 REGISTRATION SUCCESS TEST CASE .......................................................... 72 TABLE 5.2 REGISTRATION FAILURE (DUPLICATE EMAIL) TEST CASE ...................... 73 TABLE 5.3 LOGIN SUCCESS TEST CASE ....................................................................... 74 TABLE 5.4 LOGIN FAILURE (WRONG PASSWORD) TEST CASE .................................. 75 TABLE 5.5 SLOT BOOKING SUCCESS TEST CASE ........................................................ 76 TABLE 5.6 SLOT BOOKING FAILURE (NO SLOTS) TEST CASE .................................... 77 TABLE 5.7 ANPR CHECK-IN (PRE-BOOKED) TEST CASE ............................................ 78 TABLE 5.8 ANPR CHECK-IN (DRIVE-IN, LOT FULL) TEST CASE ................................... 79 TABLE 5.9 STRIPE PAYMENT SUCCESS TEST CASE ...................................................... 80 TABLE 5.10 STRIPE PAYMENT FAILURE TEST CASE ..................................................... 81 ix [PAGE BREAK] **List of Figures** FIGURE 4.1 USE CASE DIAGRAM ................................................................................... 52 FIGURE 4.2 SEQUENCE DIAGRAM OF ADVANCE BOOKING ........................................ 59 FIGURE 4.3 SEQUENCE DIAGRAM OF AUTONOMOUS CHECK-IN ............................. 60 FIGURE 4.4 CLASS DIAGRAM OF SYSTEM .................................................................... 62 FIGURE 4.5 DATA FLOW DIAGRAM (CONTEXT LEVEL 0) .......................................... 64 FIGURE 4.6 DATA FLOW DIAGRAM (LEVEL 1) ............................................................. 64 FIGURE 5.1 LANDING PAGE SCREENSHOT .................................................................... 82 FIGURE 5.2 SIGN UP PAGE SCREENSHOT ...................................................................... 82 FIGURE 5.3 SIGN IN PAGE SCREENSHOT ....................................................................... 83 FIGURE 5.4 USER DASHBOARD SCREENSHOT .............................................................. 83 FIGURE 5.5 BOOKING PAGE SCREENSHOT .................................................................... 84 FIGURE 5.6 ADMIN DASHBOARD SCREENSHOT .......................................................... 84 x [PAGE BREAK] **CHAPTER NO 1 INTRODUCTION** [PAGE BREAK] ### **1.1 Introduction to Project** The relentless pace of urbanization and the corresponding surge in vehicle ownership have placed immense pressure on civic infrastructures, with parking emerging as a significant and persistent daily challenge for commuters worldwide. Traditional parking facilities, which form the backbone of parking infrastructure in many commercial hubs and public spaces, are predominantly reliant on manual processes. These conventional systems involve human operators for issuing tickets, managing barrier gates, and collecting payments. This methodology is not only labor-intensive but is also fraught with inefficiencies, leading to long vehicle queues, suboptimal use of available space, and a high propensity for revenue leakage and human-induced errors. The end-user experience is frequently defined by frustration, wasted time, and unnecessary fuel consumption as drivers circle lots in search of an available parking space. This project, **"SmartPark: An AI-Powered Autonomous Parking Management System,"** is conceived and developed to address this clear and pervasive market gap. While technology has catalyzed transformative changes across numerous sectors, the parking industry has, in many regions, remained largely untouched by modern innovation. There exists a critical need for a more intelligent, automated solution capable of managing the entire parking lifecycle—from locating a vacant spot to processing the final payment—without necessitating significant intervention from either the driver or a human operator. The convergence of affordable high-resolution camera technology with profound advancements in Artificial Intelligence (AI) and cloud computing presents a fertile ground for creating a truly autonomous and seamless system. By integrating AI-driven Automatic Number Plate Recognition (ANPR), our project aims to develop an intelligent ecosystem that not only manages parking allocations with high efficiency but also delivers a superior, touchless, and user-friendly experience. The system is built upon a robust and scalable technology stack, featuring the **.NET Framework** and **C#** for backend logic, and a **Microsoft SQL Server (MSSQL)** database for data persistence, ensuring a reliable and enterprise-grade foundation. This document outlines the comprehensive journey of developing this system, from conceptualization and design to implementation and testing, presenting a viable solution to a modern-day problem. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **1.2 Purpose of Project** The primary purpose of the SmartPark project is to engineer a comprehensive, technology-driven solution that rectifies the inherent flaws of traditional parking management systems. The project aims to transition the parking experience from a manual, stressful ordeal into an automated, efficient, and convenient process for all stakeholders involved. The underlying motivation is to bridge the identified market gap by creating a system that is not just a marginal improvement but a fundamental rethinking of how parking facilities should operate in a technologically advanced society. **For the End-User (Vehicle Owner):** The foremost purpose is to enhance the user experience by eliminating uncertainty and saving valuable time. In today's fast-paced world, time is a critical commodity, and the minutes or even hours spent searching for parking and waiting in queues are a significant source of daily frustration. By providing a web portal for pre-booking and real-time availability checks, the system empowers users with the ability to plan their journeys with the assurance of a guaranteed parking spot. The integration of the **Stripe** payment gateway further serves this purpose by offering a secure, familiar, and cashless transaction method, enhancing convenience and personal security. The project’s goal is to make the process of parking as simple as driving in and driving out. **For the Business (Parking Facility Operator):** From a business perspective, the purpose is to dramatically improve operational efficiency, maximize revenue, and gain actionable insights into their operations. Conventional systems are plagued by high labor costs associated with round-the-clock staffing and the inherent risks of manual cash handling. By automating the entry, exit, and payment processes, the system significantly reduces the reliance on manual labor, thereby lowering operational overheads. The accurate, automated logging of every vehicle and transaction minimizes revenue leakage and provides administrators with a transparent and detailed overview of their operations through a dedicated dashboard. Furthermore, the data collected on parking patterns can inform strategic decisions, such as dynamic pricing or promotional offers, to maximize profitability. In essence, the purpose of SmartPark is to introduce a paradigm shift in parking management, creating a smarter, more organized, and more profitable urban mobility ecosystem that benefits both the individuals it serves and the businesses that provide the service. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **1.3 How it Works** The SmartPark system operates through a seamless integration of hardware and software components, designed to automate every step of the parking process. The workflow is logical and user-centric, ensuring a smooth journey from start to finish. **1. User Interaction via Web Portal:** The user's journey typically begins on the SmartPark web portal. This portal is a responsive web application, meticulously crafted using **HTML, CSS, and JavaScript**, and styled with modern frameworks like **Bootstrap and Tailwind CSS** to ensure a flawless experience on any device. * **Registration and Profile Management:** New users can register for an account using their email address. Once registered, they can log in to a personal dashboard where they can manage their profile and add their vehicle details, most importantly the number plate and the type of vehicle (e.g., car, bike, van). * **Booking and Payment:** The portal displays real-time parking availability. A user can select one of their registered vehicles, choose a desired date and entry time, and pre-book a slot. The booking process culminates in a secure online payment, handled by the integrated **Stripe** payment gateway. **2. Autonomous Entry Process:** The physical entrance of the parking facility is the next touchpoint. * **Vehicle Detection and Plate Recognition:** The entrance is monitored by a high-resolution visual camera integrated with an **AI-powered ANPR system**. As a vehicle approaches the barrier, the camera captures a clear image of its number plate. The ANPR software, running either on-camera or on a local gateway, processes the image, extracts the alphanumeric characters of the plate, and sends this data string to the SmartPark backend system via a secure API call. **3. Backend Verification and Slot Allotment:** The heart of the system is the backend application, developed in **C# on the .NET Framework**. * **Data Processing:** Upon receiving the number plate, the backend queries its **MSSQL database** to verify the vehicle's status. * **Case 1: Pre-Booked Vehicle:** If the number plate matches an active, pre-paid booking for the current time, the system validates the entry. * **Case 2: Drive-in User:** If no booking is found, the system checks the real-time database for the availability of a slot corresponding to the vehicle's type. * **Access Control:** If the entry is validated in either case, the backend sends an electronic signal to the barrier gate controller, commanding it to open. If the lot is full for a drive-in user, the barrier remains closed, and a "Lot Full" message can be displayed on a nearby screen. **4. Autonomous Exit Process:** The exit process mirrors the entry process in its automation. * **Departure Detection:** A vehicle approaching the exit is detected by another ANPR camera, which captures the plate and sends it to the backend. * **Session Finalization:** The backend retrieves the corresponding active parking session from the database. It calculates the total parking duration based on the recorded entry time. For drive-in users, the system calculates the final fee. * **Payment Verification and Exit:** For pre-booked users, the payment is already settled. For drive-in users, the system would verify if payment has been made (e.g., via a "pay-on-foot" kiosk or a mobile payment within the app). Once the system confirms the session is fully paid, it sends the "Open" command to the exit barrier. **5. Real-Time System Update:** As soon as a vehicle successfully exits, the system de-allocates the parking slot in the **MSSQL database**. This action immediately increments the public availability count for that vehicle type, ensuring that the data displayed on the web portal is always accurate and reflects the true state of the parking facility. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **1.4 Scope of Project** The scope of a project defines its boundaries, outlining what will be delivered and what will not. A clearly defined scope is essential for managing expectations and ensuring the project remains focused and achievable within the given timeframe and resources. The scope of the SmartPark project is to design, develop, and deploy a fully functional prototype that demonstrates the core features of an autonomous parking management system. **In-Scope Functionalities:** The following modules and functionalities are considered within the scope of this project: * **User Module:** This includes all functionalities related to the end-user. A secure web-based portal will be developed allowing users to perform: * New user registration with email verification. * Secure login and logout. * Profile management to update personal details. * Vehicle management to add, edit, or delete vehicle information, specifically the number plate and vehicle type. * **Booking Module:** This module will provide all features related to advance reservations. * Display of real-time parking slot availability, categorized by vehicle type. * An intuitive interface for logged-in users to select a vehicle and book a slot for a specific date and time. * Generation of a booking confirmation upon successful payment. * A history log for users to view their past and upcoming bookings. * **Payment Module:** This module focuses exclusively on financial transactions. * Seamless integration of the **Stripe** payment gateway. * Secure handling of the payment process for pre-bookings, where users are redirected to Stripe's secure environment. * Recording of transaction status (success/failure) in the local **MSSQL** database. * **ANPR Integration Module:** This module defines the system's interaction with the vehicle identification hardware. * Development of secure backend API endpoints designed to receive number plate data from an ANPR camera system. * The system logic will be fully implemented to process this data. For the purpose of this project, the physical ANPR camera will be simulated using API testing tools like Postman to send number plate data to the backend. * **Core Parking Logic Module:** This is the central processing unit of the system, built in **C#/.NET**. * Manages real-time slot allocation and de-allocation. * Handles the distinct workflows for pre-booked versus drive-in vehicles. * Calculates parking fees based on duration and predefined rates. * Manages the state of all active parking sessions. * **Administrator Module:** This module provides the necessary tools for facility operators. * A secure, role-based login for administrative staff. * A web-based dashboard to monitor real-time occupancy and key statistics. * Functionality to view and manage registered users. * Generation of basic financial and operational reports. **Out-of-Scope Elements:** To maintain focus and ensure project completion, the following elements are explicitly considered out of scope for this phase: * The physical procurement, installation, and networking of cameras, barrier gates, servers, or any other hardware. * The research and development of the core Artificial Intelligence model for ANPR. The project will operate on the assumption that it is integrating with a pre-existing, functional ANPR service via its API. * The development of a native mobile application for iOS or Android. The user interface is exclusively a responsive web portal. * Advanced business features such as dynamic pricing (where rates change based on demand), a "find my car" feature using indoor positioning, or integration with third-party navigation apps like Google Maps or Waze. * Support for managing multiple, geographically distinct parking lot locations from a single instance of the application. The current scope is for a single-facility deployment. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **1.5 Feasibility** A thorough feasibility study is a critical preliminary step in any software engineering project. It assesses the project's viability from various angles to determine whether it is a worthwhile endeavor. For the SmartPark project, a comprehensive analysis was conducted across technical, economic, operational, and legal dimensions. The findings of this study strongly support the feasibility and potential success of the project. #### **1.5.1 Technical Feasibility** Technical feasibility evaluates whether the proposed system can be successfully designed and implemented using current technology and expertise. The SmartPark system is deemed highly feasible from a technical standpoint. * **Maturity of the Technology Stack:** The project is built upon a foundation of mature, stable, and well-supported technologies. The **.NET Framework** and **C#** language, backed by Microsoft, are industry standards for developing robust, enterprise-grade web applications. They offer a rich class library, excellent performance, and built-in security features. Similarly, **Microsoft SQL Server (MSSQL)** is a powerful and reliable relational database system capable of handling the transactional load and data storage requirements of this project. * **Development Environment and Tools:** The availability of a powerful and integrated development environment (IDE) like **Microsoft Visual Studio** is a significant asset. Visual Studio provides a comprehensive suite of tools for coding, debugging, testing, and database management, which greatly accelerates the development cycle and improves code quality. The seamless integration between Visual Studio, .NET, and MSSQL creates a highly productive development ecosystem. * **Frontend Technologies:** The choice of standard web technologies (**HTML, CSS, JavaScript**) ensures broad compatibility and accessibility. The use of established CSS frameworks like **Bootstrap** and **Tailwind CSS** simplifies the process of creating a complex, responsive, and professional user interface, allowing developers to focus on functionality rather than building every UI component from scratch. * **Third-Party API Availability:** A key architectural decision was to leverage specialized third-party services for ANPR and payments. This is a common and sound engineering practice. Both AI-powered ANPR providers and the **Stripe** payment gateway offer extensive, well-documented, and developer-friendly APIs. This makes the integration process a matter of standard software development rather than requiring niche or esoteric knowledge. The availability of SDKs (Software Development Kits) for .NET further simplifies this integration. * **Expertise and Knowledge Base:** The technologies chosen are widely used, meaning there is a vast body of knowledge available in the form of official documentation, online tutorials, technical forums (like Stack Overflow), and community support. This accessibility of information mitigates the risk of encountering insurmountable technical roadblocks. Given these factors, the project team possesses the necessary tools and access to knowledge to overcome any technical challenges that may arise during the development process. The project does not rely on unproven or experimental technology, making its technical implementation a low-risk endeavor. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] #### **1.5.2 Economic Feasibility** Economic feasibility, also known as a cost-benefit analysis, assesses whether the financial benefits of the project are likely to outweigh the costs. The SmartPark project presents a strong case for being economically viable and profitable in the long run. **Project Costs:** The costs associated with the project can be divided into two main categories: 1. **One-Time Costs (Capital Expenditure):** * **Development Costs:** This is the cost associated with the man-hours required for the entire software development lifecycle, including analysis, design, implementation, and testing. * **Hardware Costs:** For a live deployment, this would include the cost of servers, high-resolution IP cameras, networking equipment (routers, switches), and automated barrier gates. * **Software Licensing:** While development can be done using free editions (Visual Studio Community, MSSQL Express), a production environment would require licenses for Windows Server, MSSQL Standard Edition, and potentially a subscription to a premium ANPR service. 2. **Recurring Costs (Operational Expenditure):** * **Server Hosting/Maintenance:** Monthly or annual costs for cloud hosting (e.g., Microsoft Azure) or maintaining physical servers. * **Third-Party Service Fees:** Stripe charges a small percentage and a fixed fee per transaction. The ANPR service may also have a monthly subscription fee. * **Support and Maintenance:** Costs associated with ongoing software updates, bug fixes, and technical support. **Project Benefits (Return on Investment):** The financial benefits are substantial and are expected to quickly offset the initial investment. 1. **Drastic Reduction in Operational Costs:** This is the most immediate and significant economic benefit. By automating the entire parking process, the system virtually eliminates the need for a large team of parking attendants and cashiers working in shifts. This translates into massive savings on salaries, benefits, and other HR-related overheads. 2. **Elimination of Revenue Leakage and Fraud:** Manual cash handling is notoriously susceptible to errors and theft. An automated, cashless system where every transaction is digitally logged ensures that all revenue is accurately captured and accounted for. This transparency and accuracy can lead to a significant increase in collected revenue, often estimated to be between 10-25% for facilities switching from manual systems. 3. **Increased Revenue Through Optimization and Attraction:** * **Improved Throughput:** The speed of the automated system allows more vehicles to enter and exit the facility during peak hours, increasing the total number of customers that can be served in a day. * **Enhanced Customer Attraction:** In a competitive market, a parking facility offering the convenience of pre-booking, guaranteed spots, and a hassle-free experience becomes a more attractive option for customers. This can increase market share and overall vehicle traffic. 4. **Data-Driven Business Intelligence:** The system collects a wealth of data on parking patterns (e.g., peak hours, average duration, popular vehicle types). This data is a valuable asset that can be used to make informed business decisions, such as implementing demand-based pricing, offering targeted promotions, or planning for future expansions. **Conclusion of Economic Feasibility:** When the substantial savings from reduced labor costs and the increased revenue from eliminating leakage and attracting more customers are weighed against the one-time development and hardware costs, the economic feasibility of the SmartPark project is exceptionally strong. The system is not just a technological upgrade but a sound financial investment that promises a rapid return and long-term profitability. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] #### **1.5.3 Operational Feasibility** Operational feasibility assesses how well the proposed system solves the problems and fits into the existing operational environment of the organization. It is concerned with the human and procedural aspects of the project's implementation. The SmartPark system is designed to be highly feasible from an operational standpoint, simplifying existing processes and being readily adoptable by all stakeholders. **Impact on Existing Operations:** The primary impact of SmartPark is the automation of manual, repetitive tasks. This fundamentally changes the nature of the work for on-site staff. * **Shift from Manual Labor to System Supervision:** The role of the parking attendant shifts from being a ticket-issuer and cashier to a system supervisor and customer service representative. Instead of performing mundane tasks, the staff can focus on higher-value activities, such as assisting customers with queries, ensuring the safety and security of the premises, and managing exceptions that the automated system may flag for review. This leads to a more engaged and efficient workforce. * **Streamlined Auditing and Reporting:** The process of financial reconciliation, which is often a time-consuming daily task in manual systems, becomes instantaneous. The admin dashboard provides accurate, real-time revenue reports, eliminating the need for manual cash counting and complex audits. **User Adoptability:** The success of any new system depends heavily on how easily its intended users can adopt it. * **For Vehicle Owners (Drivers):** The system is designed to be as frictionless as possible. For drive-in users, the experience is completely seamless—they simply drive in and out. For users of the web portal, the interface is designed to be intuitive and follows standard web conventions for registration and booking, making it easy to learn for anyone familiar with using websites or apps. The use of a trusted payment gateway like **Stripe** also lowers the barrier to adoption, as users are more comfortable transacting through a familiar and secure platform. * **For Administrators:** The administrative dashboard will be a graphical, web-based interface. It will use clear labels, charts, and tables to present complex information in an easily digestible format. Staff with basic computer skills can be trained to use the dashboard effectively in a very short amount of time. The system simplifies their workflow rather than complicating it. **Procedural Changes:** The project requires minimal disruptive changes to core business procedures. While the specific tasks of entry/exit management change, the overall business goal of providing parking services remains the same. The system is designed to support, not replace, the essential business process. In the event of a system malfunction (e.g., a power outage or camera failure), the design will include procedural fallbacks, such as a manual override for the barrier gates, ensuring that the facility can remain operational under adverse conditions. In conclusion, the SmartPark system is operationally feasible because it enhances, rather than disrupts, the existing operational framework. It empowers staff by automating tedious tasks, is intuitive for customers to use, and includes safeguards to ensure continued operation, making the transition from a manual to an automated system smooth and highly beneficial. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] #### **1.5.4 Legal and Ethical Feasibility** A project that involves the collection of public data (license plates) and personal user information must be scrutinized for its legal and ethical implications. The SmartPark project has been designed with these considerations at its core to ensure it operates in a responsible, compliant, and trustworthy manner. **Legal Feasibility:** The legal viability of the system hinges on its compliance with data protection laws and financial regulations. * **Data Protection and Privacy Laws:** Most countries and regions have specific laws governing the collection and processing of Personal Identifiable Information (PII). In Europe, this is the GDPR; other regions have similar legislation. The SmartPark system will adhere to the core principles of these laws: * **Lawfulness, Fairness, and Transparency:** The system's privacy policy will clearly state what data (name, email, number plate) is being collected, why it is being collected (for the purpose of providing parking services), and how it is being processed. Users will be required to consent to these terms during registration. * **Data Minimization:** The system is designed to collect only the data that is absolutely necessary to function. It does not collect sensitive personal data beyond what is needed for account management and vehicle identification. * **Storage Limitation and Security:** Data will be kept only for as long as it is necessary (e.g., for financial auditing purposes). The data will be stored securely in the **MSSQL** database, protected by strong access controls, and all user passwords will be hashed and salted. * **Financial Regulations (PCI-DSS):** The Payment Card Industry Data Security Standard (PCI-DSS) is a set of security standards designed to ensure that all companies that accept, process, store, or transmit credit card information maintain a secure environment. Attempting to build a compliant payment system from scratch is a massive and legally complex undertaking. The SmartPark project mitigates this entire category of legal risk by integrating **Stripe**, a certified PCI-DSS Level 1 Service Provider. By using Stripe's hosted checkout pages and APIs, our system never directly handles or stores any sensitive credit card data. All payment processing is offloaded to Stripe's secure infrastructure, ensuring full legal compliance with financial regulations. **Ethical Feasibility:** Beyond legal compliance, the project must operate in an ethical manner to build and maintain user trust. * **Transparency:** The system's operation will be transparent. Fee calculations will be based on clear, published rates. There are no hidden charges. Users will understand that their number plate is being used for the sole purpose of automating their entry and exit. * **Fairness and Non-Discrimination:** The automated system applies the same rules to all users, eliminating the potential for human bias that can occur in manual systems. Access and fees are determined by objective data (time and vehicle type), ensuring a fair experience for everyone. * **Data Governance:** The project commits to ethical data governance. The data collected, particularly vehicle movement data, will be anonymized and aggregated if used for analytics. It will not be sold or shared with third-party marketing companies. The primary use of the data is to improve the parking service itself. * **Accountability:** The system will have logging mechanisms to create an audit trail of significant events (e.g., entry, exit, payment, admin actions). This provides accountability and allows for the investigation of any disputes or discrepancies. By proactively building the system on a foundation of legal compliance and ethical principles, the SmartPark project ensures its long-term viability and establishes itself as a trustworthy service provider in the eyes of its users. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **1.6 Risk Management** A proactive and structured approach to risk management is integral to the successful execution of the SmartPark project. Risk management involves identifying potential threats to the project's success, assessing their potential impact, and establishing clear mitigation strategies to minimize or eliminate them. The identified risks are categorized into technical, project management, and external risks. | **Risk Category** | **Risk Identification** | **Impact** | **Likelihood** | **Mitigation Strategy** | | :------------------ | :----------------------------------------------------------------------------------------------------------------------------- | :--------- | :------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | **Technical Risks** | **Inaccuracy of the ANPR System:** The third-party ANPR service may fail to read a number plate accurately due to poor lighting, bad weather, an angled view, or a dirty plate. | High | Medium | 1. **Vendor Selection:** Select a high-quality, AI-powered ANPR service provider with a proven track record and a Service Level Agreement (SLA) for accuracy. <br> 2. **Manual Override:** Implement a feature in the admin dashboard for an operator to manually input a number plate and open the barrier in the rare case of a read failure. <br> 3. **Error Handling:** The system will log uncertain or failed reads for later review to identify potential issues with camera placement or lighting. | | **Technical Risks** | **System Downtime:** The backend server, database, or network could experience an outage, making the entire automated system non-operational. | High | Low | 1. **Cloud Hosting:** Deploy the application and database on a reputable cloud platform (e.g., Microsoft Azure) that offers high uptime guarantees (e.g., 99.9%). <br> 2. **Redundancy and Backups:** Implement regular, automated backups of the **MSSQL** database to a geographically separate location. For critical deployments, a load-balanced or failover server setup can be configured. <br> 3. **Monitoring:** Use health check monitoring services to immediately alert administrators via email or SMS if any part of the system becomes unresponsive. | | **Technical Risks** | **Security Breach:** A malicious actor could attempt to exploit a vulnerability in the web application to gain unauthorized access to user data or disrupt service. | Critical | Medium | 1. **Secure Coding Practices:** Adhere to OWASP (Open Web Application Security Project) guidelines throughout development. Use parameterized queries (handled by Entity Framework) to prevent SQL injection, validate all user input, and implement CSRF tokens. <br> 2. **Robust Authentication:** Use strong password hashing (bcrypt) and implement role-based authorization. <br> 3. **HTTPS:** Enforce HTTPS for all communication. <br> 4. **Regular Audits:** Conduct periodic vulnerability scans and penetration testing on the deployed application. | | **Project Management** | **Scope Creep:** Uncontrolled addition of new features and requirements during the development process, leading to delays and budget overruns. | High | High | 1. **Clear Scope Definition:** Maintain a detailed and formally approved scope document at the project's outset. <br> 2. **Formal Change Control:** Establish a change control board or process. Any proposed change to the scope must be formally submitted, evaluated for its impact on schedule and cost, and approved before being added to the development backlog. | | **Project Management** | **Dependency Delays:** Delay in receiving necessary information, access, or components from a third party (e.g., ANPR service API documentation, Stripe account setup). | Medium | Medium | 1. **Early Engagement:** Initiate contact and setup with third-party vendors as early as possible in the project lifecycle. <br> 2. **Develop with Mocks:** Create mock or simulated versions of the external APIs. This allows the development team to proceed with building and testing the core application logic without being blocked by the external dependency. The mock can be replaced with the real API once it becomes available. | | **External Risks** | **Low User Adoption:** End-users may be hesitant to use the web portal for booking or may not trust the online payment system, preferring traditional methods. | High | Medium | 1. **User-Centric Design:** Design an exceptionally simple, intuitive, and trustworthy user interface. <br> 2. **Incentivization:** Offer a small discount for the first few online bookings to encourage trial. <br> 3. **Clear Communication:** Use on-site signage and information on the website to clearly explain the benefits of the new system (e.g., "Book online and save time!"). Emphasize the security of the **Stripe** payment system. | | **External Risks** | **Changes in Regulations:** A change in data privacy laws or financial regulations could require significant modifications to the system. | Medium | Low | 1. **Modular Architecture:** Design the system in a modular way. The components that handle user data and payments should be loosely coupled from the core parking logic. This allows these modules to be updated or replaced to meet new regulations without a complete system rewrite. <br> 2. **Ongoing Compliance Review:** Assign responsibility for periodically reviewing changes in relevant legal and regulatory frameworks. | By actively monitoring and managing these risks throughout the project lifecycle, the team can significantly increase the probability of delivering a successful, secure, and robust system on time and within budget. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **1.7 Project Planning** Effective project planning is the foundation for a successful project. It involves breaking down the work into manageable phases, defining clear deliverables, and establishing a timeline for completion. The SmartPark project will be executed using an Agile development methodology, which emphasizes iterative development, collaboration, and flexibility to adapt to changes. The entire project is divided into five distinct phases. **Phase 1: Analysis and Design (4 Weeks)** This initial phase is dedicated to laying a solid groundwork for the entire project. It is crucial to get this phase right, as all subsequent work will be built upon its outputs. * **Week 1: Requirement Finalization:** Conduct final stakeholder meetings to confirm and formally document all functional and non-functional requirements. * **Week 2: Use Case and Architectural Design:** Develop detailed use case descriptions and diagrams. Design the high-level system architecture (Three-Tier Architecture) and data flow diagrams (DFDs). * **Week 3: Database and Class Design:** Design the complete, normalized database schema (ERD) for the **MSSQL** database. Create the corresponding UML Class Diagram to model the system's objects and their relationships. * **Week 4: UI/UX Wireframing:** Create detailed wireframes and mockups for every screen of the user web portal and the admin dashboard. This provides a visual blueprint for the frontend development phase. **Phase 2: Core Backend Development (5 Weeks)** This phase focuses on building the server-side logic and database structure. * **Week 5: Environment Setup & Database Implementation:** Set up the development environment (**Visual Studio, MSSQL Server, Git**). Implement the database schema using Entity Framework's Code-First approach. * **Week 6-7: User and Authentication Module:** Develop the backend API for user registration, secure login (using JWT), profile management, and vehicle management. * **Week 8-9: Core Parking Logic Module:** Implement the backend logic for session management, fee calculation, and the API endpoints that will interface with the (simulated) ANPR system. Conduct comprehensive unit testing for all developed backend components. **Phase 3: Frontend and Payment Integration (5 Weeks)** This phase brings the user interface to life and integrates the critical payment functionality. * **Week 10-11: User Portal Frontend Development:** Develop the HTML, CSS, and JavaScript for the user-facing web portal, based on the wireframes from Phase 1. Use **Bootstrap** and **Tailwind CSS** for styling. * **Week 12: Frontend-Backend Integration:** Connect the user portal to the backend APIs using **jQuery AJAX** calls. Ensure data flows correctly for login, registration, and dashboard display. * **Week 13: Booking Module and Stripe Integration:** Develop the booking functionality on both the backend and frontend. Integrate the **Stripe** payment gateway into the booking workflow. * **Week 14: Admin Dashboard Development:** Develop the frontend for the Admin Dashboard and connect it to the secure administrative APIs. **Phase 4: System Integration and Testing (4 Weeks)** This phase is dedicated to ensuring all parts of the system work together correctly and meet the quality standards. * **Week 15: ANPR Integration and Testing:** Finalize and test the API endpoints for the ANPR system using simulation tools like Postman. * **Week 16-17: Comprehensive System Testing:** Conduct thorough integration testing to verify seamless data flow between all modules. Execute all predefined end-to-end system test cases to validate the complete application functionality. * **Week 18: Usability Testing and Refinement:** Conduct usability testing sessions with a small group of sample users. Gather feedback on the user portal's design and ease of use, and make necessary refinements. **Phase 5: Finalization and Deployment (2 Weeks)** This is the final phase to wrap up the project. * **Week 19: Final Documentation and Deployment:** Finalize the project report and all supporting documentation. Deploy the completed application to a staging or production server environment. * **Week 20: Demonstration Preparation and Project Closure:** Prepare a comprehensive demonstration of the live system. Conduct a final project review and formally close the project. This structured, phased plan provides a clear roadmap for the project, with specific, measurable milestones at each stage, ensuring that progress is tracked effectively and the project is delivered on schedule. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **1.8 Project Modules** A modular architecture is a key software design principle that involves separating a program's functionality into independent, interchangeable modules. Each module contains everything necessary to execute one aspect of the desired functionality. This approach makes the SmartPark system easier to develop, test, maintain, and scale. The system is logically divided into the following primary modules: **1. Authentication and User Management Module** * **Purpose:** This module serves as the gateway to the system for all users. It is responsible for verifying user identities and managing their personal and vehicle-related information. It is a foundational module upon which most other user-facing features depend. * **Core Functionalities:** * New user registration form and validation logic. * Secure user login and logout mechanisms. * Password management, including secure hashing (using bcrypt) and potentially a "forgot password" feature. * A user dashboard for viewing and editing profile information. * An interface for users to add, update, or delete their vehicle details (number plate, vehicle type). * **Key Technologies:** **C#/.NET** for the backend API logic, **MSSQL** for storing user and vehicle data, and JWT (JSON Web Tokens) for managing authenticated sessions. **2. Booking and Payment Module** * **Purpose:** This module provides the core transactional functionality for users wishing to reserve a parking spot in advance. It combines scheduling, availability checks, and financial processing into a single, streamlined workflow. * **Core Functionalities:** * Displaying real-time slot availability to users. * A booking interface to select a vehicle, date, and time. * Calculation of booking fees. * Integration with the **Stripe** payment gateway to handle secure online payments. * Generation of booking confirmations and management of booking statuses (e.g., Confirmed, Completed, Cancelled). * **Key Technologies:** **C#/.NET** for booking logic, **jQuery AJAX** for dynamic frontend interaction, and the official **Stripe.net** library for payment processing. **3. Core Parking and ANPR Integration Module** * **Purpose:** This is the operational heart of the SmartPark system. It contains the real-time business logic that automates the physical parking process. It acts as the bridge between the digital world of bookings and the physical world of vehicles entering and leaving the facility. * **Core Functionalities:** * An API endpoint to receive number plate data from the external ANPR system. * Logic to differentiate between pre-booked and drive-in vehicles. * Real-time slot allocation and de-allocation algorithms. * Management of the entire lifecycle of a `ParkingSession` from entry to exit. * Communication with the barrier gate control system (simulated via API response). * **Key Technologies:** **C#/.NET** for the high-performance, real-time processing logic. **4. Administrator and Reporting Module** * **Purpose:** This module provides the necessary tools for the parking facility operators to manage and monitor the system. It is a secure, back-office interface that offers a comprehensive view of the entire operation. * **Core Functionalities:** * Secure, role-based login for administrators. * A real-time dashboard displaying key performance indicators (KPIs) like current occupancy, total entries/exits for the day, and live revenue totals. * Tools to search, view, and manage registered user accounts. * A reporting engine to generate historical reports on revenue, occupancy rates, and other operational metrics. * **Key Technologies:** A protected area within the **.NET** application, with a user interface built using **HTML/CSS/JS** and data visualization libraries for charts. **5. Frontend / User Interface Module** * **Purpose:** This module encompasses all the visual and interactive elements that the end-users (both public users and administrators) interact with. Its goal is to provide a clean, intuitive, and efficient user experience. * **Core Functionalities:** * The public-facing website, including the home page, login/registration pages, and booking forms. * The secure user dashboard. * The secure admin dashboard. * **Key Technologies:** **HTML** for structure, **CSS** (with **Bootstrap** and **Tailwind CSS**) for responsive styling, and **JavaScript/jQuery** for client-side interactivity and communication with the backend APIs. This modular design ensures a clear separation of concerns, which is a hallmark of well-engineered software. It allows different parts of the system to be developed and updated independently, leading to a more robust and maintainable final product. [PAGE BREAK] **CHAPTER NO 2 BACKGROUND AND PROBLEM DEFINITION** [PAGE BREAK] ### **2.1 Background Research** The management of vehicle parking has become an increasingly complex and critical component of urban planning and smart city initiatives. Historically, parking was a simple affair, but the exponential growth of vehicle ownership since the mid-20th century has transformed it into a significant logistical challenge. The search for parking is a major contributor to traffic congestion, with studies indicating that up to 30% of traffic in congested urban areas is composed of drivers looking for a parking spot (Shoup, 2017). This activity not only wastes drivers' time and fuel but also contributes significantly to air and noise pollution, degrading the quality of urban life. Traditional parking management systems, which have been the standard for decades, are based on manual operations. These systems typically involve human attendants issuing physical tickets at the entry, visually monitoring the lot, and collecting cash payments upon exit. While functional at a basic level, this model is inherently inefficient and ill-suited for the demands of modern cities. Research by the International Parking Institute (IPI, 2019) has consistently highlighted the limitations of these systems, including slow processing times that create bottlenecks, high and recurring labor costs, a high susceptibility to human error in fee calculation, and significant risks of revenue leakage through fraud or mismanagement. Furthermore, these systems generate little to no useful data for operational analysis, leaving facility owners unable to make informed, data-driven decisions to optimize their business. In response to these challenges, the field of "Smart Parking" has emerged over the last two decades. This domain focuses on applying modern information and communication technologies (ICT) to improve the efficiency, convenience, and profitability of parking. Early smart parking solutions focused on vehicle detection technologies. These included the use of inductive loop detectors buried in the pavement or, more commonly, ultrasonic sensors mounted above individual parking bays. These sensors could detect the presence or absence of a vehicle and transmit this data to a central server. This allowed for accurate, space-by-space availability monitoring, which could then be displayed on large digital signboards at the entrance of a parking garage or along city streets to guide drivers to vacant spots. While these systems provide accurate real-time data, their high per-space installation and maintenance costs have limited their widespread adoption, especially in large, open-air parking lots (Lin et al., 2018). More recently, advancements in computer vision and the commoditization of high-resolution cameras have shifted the focus towards camera-based solutions. Automatic Number Plate Recognition (ANPR), also known as License Plate Recognition (LPR), has been identified as a key enabler for creating truly ticketless, frictionless, and seamless parking experiences. ANPR leverages optical character recognition (OCR) on images to automatically read vehicle license plates. This technology eliminates the need for any physical tokens (like paper tickets or RFID cards) or direct user actions (like scanning a QR code), allowing for a completely autonomous flow of vehicles in and out of a facility. This project, SmartPark, is situated at the forefront of this technological trend. It aims to create a holistic system that not only leverages the power of ANPR for autonomous access control but also integrates it with a sophisticated web-based management platform built on the **.NET Framework**. This platform provides features like advance booking and secure online payments via **Stripe**, addressing the full spectrum of user and operator needs in a single, cohesive solution. The research indicates a clear market demand for such integrated systems that move beyond simple vehicle detection to offer a complete, end-to-end managed service. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **2.2 Existing Technology and Their Limitations** To fully appreciate the innovative contribution and market positioning of the SmartPark project, it is essential to conduct a thorough review of the spectrum of existing technologies currently employed in the parking management industry. Each technology represents a step in the evolution of parking systems, and each comes with its own set of advantages and inherent limitations. **1. Manual Ticketing and Cash Payment Systems** * **Description:** This is the most traditional and basic method. A human attendant is stationed at the entrance to manually issue a time-stamped paper ticket to each entering vehicle. Upon exit, the user presents this ticket to another attendant, who visually calculates the duration, determines the fee, and collects payment, almost always in cash. The attendant then manually operates the boom barrier. * **Advantages:** * Extremely low initial investment in technology. * The process is simple to understand for all demographics of users. * **Limitations:** * **Highly Inefficient:** The process is exceptionally slow, leading to long, frustrating queues at both entry and exit points, especially during peak hours. * **High Labor Costs:** This model requires significant and continuous staffing for all operational hours, making it very expensive to run. * **Prone to Error and Fraud:** Manual fee calculation can lead to mistakes. More significantly, manual cash handling creates major vulnerabilities for theft, collusion, and general revenue leakage. * **No Data:** This system provides no digital data for analysis, making it impossible for operators to understand usage patterns or optimize operations. **2. Pay-and-Display Systems** * **Description:** In this model, users find a parking space first, then walk to a central payment kiosk. At the kiosk, they purchase a ticket for a specified duration (e.g., 1 hour, 2 hours) and then must return to their vehicle to display the ticket on the dashboard. Enforcement is done by human attendants who patrol the lot and check the tickets on each vehicle. * **Advantages:** * Reduces the need for dedicated staff and barriers at every entry/exit point. * Can be implemented in open lots without defined entryways. * **Limitations:** * **Highly Inconvenient for Users:** The process is multi-stepped and inconvenient, requiring the user to walk back and forth. * **Guesswork and Risk:** Users must guess their required parking duration in advance. They often overpay to avoid fines, or underpay and risk a penalty. * **Labor-Intensive Enforcement:** Still relies entirely on manual patrolling for enforcement, which is inefficient and costly. **3. IoT Sensor-Based Systems** * **Description:** This represents a significant technological leap. Individual parking bays are fitted with sensors (commonly ultrasonic, magnetic, or infrared) that detect the presence or absence of a vehicle. This occupancy data is transmitted wirelessly to a central server. This allows the system to display highly accurate, real-time vacant spot counts on digital signboards or in a mobile application. * **Advantages:** * Provides extremely accurate, space-by-space occupancy data in real-time. * Can significantly reduce the time drivers spend searching for a spot by guiding them directly to available zones or floors. * **Limitations:** * **Prohibitively High Cost:** The primary barrier to adoption is the very high cost of hardware, installation, and ongoing maintenance. Each of the hundreds or thousands of spots in a facility needs its own sensor, battery, and communication module. * **Reliability Issues:** The sensors are physical devices exposed to the elements and potential damage. They can be prone to failure due to weather conditions, dirt, or battery depletion, requiring constant maintenance. **4. RFID/NFC-Based Systems** * **Description:** This technology is most often used for monthly or long-term contract parkers. Vehicles are fitted with a Radio-Frequency Identification (RFID) tag (often a sticker on the windshield), or users carry an NFC-enabled access card. Readers installed at the entry and exit points automatically detect the tag/card from a short distance, authenticate the user, and operate the barrier. * **Advantages:** * Provides very fast, reliable, and automated access for registered, long-term users. * **Limitations:** * **Not Suitable for General Public:** This model is not practical for transient or occasional visitors, as it requires the pre-issuance of a physical tag or card. The logistics of distributing and managing these credentials for the general public would be unmanageable. * **Infrastructure Cost:** The cost of the readers and the ongoing cost of the tags/cards can be significant. **5. QR Code and App-Based Systems** * **Description:** A more modern, low-cost approach. Users use their smartphones to scan a QR code posted at the entry or at the parking bay. This action typically launches a mobile website or app where they start their parking session. To exit, they use the app to stop the session and make an online payment. * **Advantages:** * Very low infrastructure cost, as it primarily leverages the user's own smartphone. * Easily enables cashless payments. * **Limitations:** * **Not Fully Autonomous:** The process is not truly frictionless and still requires direct user action (pulling out a phone, opening an app, scanning). This can still cause delays and is less convenient than a drive-through experience. * **High Dependency:** The system is entirely dependent on the user having a smartphone, a working camera, a stable internet connection, and sufficient battery life. This can exclude some users and is unreliable in underground lots with poor reception. **6. Stand-alone ANPR Systems** * **Description:** Many modern facilities now use ANPR for entry and exit logging. The system captures the plate on entry and again on exit to calculate the duration. However, in many of these "first-generation" smart systems, the ANPR component is not fully integrated with other services. Payment is often still handled by a separate "pay-on-foot" kiosk that the driver must visit before returning to their car. * **Advantages:** * Provides a ticketless and automated entry/exit logging experience. * **Limitations:** * **Fragmented User Journey:** While entry is smooth, the overall journey is disjointed. The driver still has to manually interact with a separate payment machine, which can be a bottleneck. * **No Pre-Booking or Guarantee:** These systems typically do not integrate with a pre-booking platform, so users still face the uncertainty of finding a spot upon arrival. **The SmartPark Advantage:** The SmartPark project is specifically designed to overcome the limitations of all these existing technologies by creating a **single, unified, and truly end-to-end system**. It uses **ANPR** as the core identification technology for a frictionless experience, but critically, it deeply integrates this with a powerful **web-based pre-booking platform** and a modern online payment gateway (**Stripe**), all orchestrated by a centralized and robust **.NET/MSSQL** backend. This holistic approach addresses the entire user journey, from planning at home to a seamless exit, which is the key market gap that current, fragmented solutions fail to fill. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **2.3 Area of Study** The development of the SmartPark system is a comprehensive undertaking that requires a multi-disciplinary approach, drawing upon established principles and modern practices from several key areas of computer science and software engineering. A deep understanding of each of these domains is essential to architect and build a solution that is not only functional but also robust, scalable, and secure. The primary areas of study for this project are detailed below. **1. Enterprise Web Application Development with the .NET Framework** * **Core Concepts:** This project is fundamentally an enterprise-level web application. The area of study, therefore, revolves around the **.NET Framework**, a powerful and versatile platform from Microsoft. The study includes a deep dive into the **ASP.NET Web API** framework, which is used to build RESTful services. This involves understanding the principles of the MVC (Model-View-Controller) architectural pattern, request/response pipelines, middleware configuration, routing, and dependency injection. These concepts are crucial for creating a clean, maintainable, and loosely coupled backend architecture. * **Programming Language:** The primary language of implementation is **C#**. This requires a thorough study of its object-oriented programming (OOP) principles, including encapsulation, inheritance, and polymorphism. Advanced C# features, such as asynchronous programming (async/await), are critical for building a high-performance server that can handle multiple concurrent requests without getting blocked, which is essential for real-time systems like SmartPark. **2. Relational Database Design and Management** * **Core Concepts:** At the heart of SmartPark lies a database that stores all critical information. This necessitates a detailed study of relational database theory. The process begins with conceptual data modeling, identifying entities, attributes, and relationships, which is then translated into a logical schema. Key principles studied include database normalization (up to the Third Normal Form, 3NF) to eliminate data redundancy and improve data integrity. * **Technology and Tools:** The chosen database technology is **Microsoft SQL Server (MSSQL)**. The study includes learning its specific SQL dialect (T-SQL) for writing queries, creating stored procedures, and defining constraints. A significant part of the study involves using an Object-Relational Mapper (O/RM) like **Entity Framework**. This framework abstracts the database interactions, allowing developers to work with **C#** objects instead of raw SQL queries, which speeds up development and reduces errors. **3. Frontend Engineering and Responsive User Interface Design** * **Core Concepts:** This area of study focuses on creating the client-facing components of the system—the web portal and dashboards. The foundation is a strong understanding of the core web technologies: **HTML5** for semantic structure, **CSS3** for presentation and styling, and **JavaScript** for client-side logic and interactivity. * **Modern Frameworks and Libraries:** To build a modern, professional-grade interface efficiently, the study extends to CSS frameworks. The project utilizes a combination of **Bootstrap**, known for its comprehensive set of pre-styled components (forms, buttons, navigation bars), and **Tailwind CSS**, a utility-first framework that allows for rapid, custom styling without writing custom CSS. This hybrid approach offers both ready-made components and fine-grained control. The study also includes the use of **jQuery**, a JavaScript library that simplifies tasks like DOM manipulation, event handling, and making asynchronous API calls (AJAX) to the backend. This is vital for creating a dynamic user experience where data can be loaded and updated without requiring a full page refresh. **4. Artificial Intelligence and Computer Vision Integration** * **Core Concepts:** While the project does not involve creating an AI model from scratch, a crucial area of study is understanding the application and integration of AI in a real-world system. The focus is on **Automatic Number Plate Recognition (ANPR)**. This involves studying the typical ANPR pipeline: 1. Image Acquisition (capturing a clear image). 2. Image Pre-processing (enhancing contrast, reducing noise). 3. License Plate Detection (locating the plate within the image). 4. Character Segmentation (isolating individual characters). 5. Optical Character Recognition (OCR) (converting character images to text). * **API Integration:** The practical study focuses on how to design a system that consumes the output of such an AI model. This involves designing a secure API endpoint in our **.NET** backend that can receive the number plate data from the ANPR system and designing a robust workflow to handle the data, including validating its format and handling cases of failed reads. **5. Secure Third-Party API Integration** * **Core Concepts:** Modern software development heavily relies on integrating external services. A critical area of study is how to do this securely and efficiently. The project focuses on integrating the **Stripe payment gateway**. * **Practical Application:** This involves a detailed study of Stripe's official API documentation, understanding its payment processing flows (specifically the "Payment Intents" API for SCA compliance), and learning how to use their .NET SDK. The study emphasizes security best practices, such as the critical importance of keeping API secret keys confidential, using webhooks for reliable, asynchronous confirmation of payment success, and ensuring no sensitive cardholder data ever touches the SmartPark server. By synthesizing knowledge from these diverse yet interconnected areas, the SmartPark project aims to deliver a well-architected, feature-rich, and secure software solution that meets the highest standards of modern application development. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **2.4 Reason for the Project** The motivation for undertaking the SmartPark project is rooted in the observation of a persistent and widespread real-world problem and the simultaneous emergence of accessible technologies capable of solving it. The project is not an academic exercise in isolation; rather, it is a direct response to a clear market need and a strategic application of modern software engineering principles. The core reasons for its inception are detailed below. **1. To Bridge a Significant and Frustrating Market Gap** The primary driver for this project is the identification of a significant gap in the current parking industry landscape. While individual "smart" technologies exist—such as separate payment apps, standalone vehicle sensors, or basic ANPR for security logging—there is a distinct lack of a single, cohesive, and fully autonomous system that integrates the entire user journey. Drivers today often face a fragmented and frustrating experience. They might use one app to find a lot with potential availability, but upon arrival, they still have to manually take a ticket, hunt for a spot, and later use a different physical kiosk to pay. SmartPark was conceived to fill this gap by providing a true all-in-one solution that seamlessly handles everything from pre-booking and online payment to autonomous, ANPR-driven entry and exit. **2. To Alleviate Urban Congestion and Improve Quality of Life** A significant body of research points to the fact that a substantial portion of traffic in dense urban centers (up to 30%) is caused by drivers circling and searching for parking. This "cruising" for parking wastes immense amounts of time and fuel, increases vehicle emissions, and adds to the overall stress and noise pollution of city life. The SmartPark project is driven by a civic-minded goal to help alleviate this problem. By providing real-time availability data and the ability to pre-book a guaranteed spot, the system eliminates the need for aimless searching. By automating entry and exit with high-speed ANPR, it dissolves the queues that traditionally spill out from parking facilities and clog city streets. **3. To Enhance User Experience Through Modern Convenience** The modern consumer, accustomed to the seamless experiences provided by e-commerce and on-demand services, has high expectations for convenience and predictability. The traditional parking experience, with its uncertainty, queues, and fumbling for cash, is an anachronism. SmartPark is fundamentally a user-centric project, designed to transform this outdated process. The ability to manage one's parking needs from a web portal, secure a spot in advance, and pay with a trusted and secure gateway like **Stripe**, provides a level of comfort and control that meets modern expectations. **4. To Provide a Compelling Business Case for Facility Operators** Beyond user convenience, the project is designed to deliver tangible business value. The operational model for most parking facilities is inefficient and costly. High labor costs, the complexities of cash management, and revenue leakage from fraud or error are major pain points for operators. SmartPark offers a compelling solution to these problems. The system, built on a reliable and secure **.NET/MSSQL** foundation, automates costly manual processes, eliminates revenue leakage through a transparent digital transaction log, and optimizes the use of parking real estate. Furthermore, it provides operators with invaluable data analytics to better understand their business and make smarter, data-driven decisions. **5. To Apply Modern Technology to a Tangible, Real-World Problem** From a computer science perspective, this project provides the perfect opportunity to apply a range of modern, high-demand technologies to solve a problem that people face every day. It allows for the practical application of enterprise web development (**.NET**), relational database management (**MSSQL**), frontend engineering (**Bootstrap, Tailwind CSS**), AI integration (**ANPR**), and secure financial API integration (**Stripe**). It serves as a comprehensive demonstration of how these disparate technologies can be orchestrated to create a complex, functional, and valuable software product. In essence, the reason for the SmartPark project is to challenge the inefficient status quo of an entire industry by introducing an intelligent, elegant, and user-friendly alternative that creates a win-win situation for both consumers and businesses. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] ### **2.5 Objectives of the Project** To transform the vision of the SmartPark system into a tangible reality, a set of specific, measurable, achievable, relevant, and time-bound (SMART) objectives has been established. These objectives serve as the guiding principles for the development process and provide the key benchmarks against which the success of the project will be evaluated. The primary goal of the project is: **To design, develop, and deploy a working prototype of an AI-powered, autonomous parking management system.** To achieve this goal, the following specific objectives have been defined: **Objective 1: To Engineer a Secure and Scalable Backend Architecture.** * **Specific Actions:** Utilize the **.NET Framework** and the **C#** programming language to build the core server-side business logic. Implement a complete set of RESTful API endpoints to handle all system functions, including user management, booking, payment processing, and parking session control. The architecture must be designed following best practices like the three-tier model to ensure it is scalable and maintainable. **Objective 2: To Implement a Robust and Normalized Relational Database.** * **Specific Actions:** Design a logical and physical database schema using **Microsoft SQL Server (MSSQL)**. The schema must be normalized to at least the Third Normal Form (3NF) to ensure data integrity and prevent redundancy. Implement the database to accurately store and manage all critical data entities, including user profiles, vehicle information, booking records, payment transactions, and live parking sessions. **Objective 3: To Integrate an Autonomous Vehicle Identification Mechanism.** * **Specific Actions:** Design and develop the system's backend to seamlessly interface with an **AI-powered Automatic Number Plate Recognition (ANPR)** service. This involves creating and thoroughly testing the secure API endpoints that will receive number plate data from an external camera system, which will be used to automate the check-in and check-out processes without any need for manual intervention. **Objective 4: To Create an Intuitive and Responsive User-Facing Web Portal.** * **Specific Actions:** Develop a feature-rich, client-facing website using **HTML, CSS, and JavaScript**. This portal must allow users to easily register, log in, manage their account, book parking slots, and view their history. Employ modern CSS frameworks like **Bootstrap** and **Tailwind CSS** to ensure the portal is fully responsive and provides an optimal user experience on all devices, from large desktops to small mobile phones. **Objective 5: To Integrate a Secure and Reliable Online Payment Gateway.** * **Specific Actions:** Incorporate the **Stripe** payment gateway directly into the user's booking workflow. This involves using the official Stripe .NET SDK on the backend and Stripe.js on the frontend. The integration must ensure that all financial transactions are handled securely, in full compliance with PCI standards, providing users with a safe and trustworthy method for online payments. **Objective 6: To Build a Functional and Insightful Administrative Dashboard.** * **Specific Actions:** Create a secure, role-based dashboard accessible only to authorized parking facility operators. This dashboard must provide administrators with the essential tools to monitor real-time parking occupancy, manage user data, view a log of all system activities, and generate basic financial and operational reports. **Objective 7: To Conduct Comprehensive System Testing and Validation.** * **Specific Actions:** Develop and execute a multi-layered testing plan that includes unit tests for individual backend functions, integration tests to verify module interactions, and end-to-end system tests to validate the complete user workflows. The system must be rigorously tested against the defined functional and non-functional requirements to ensure it is reliable, secure, and free of critical defects before final demonstration. Successfully meeting each of these objectives will result in the delivery of a complete and functional prototype of the SmartPark system, effectively demonstrating a viable and innovative solution to the multifaceted challenges of modern parking management. [PAGE BREAK] **CHAPTER NO 3 SYSTEM REQUIREMENT ANALYSIS** [PAGE BREAK] ### **3.1 System Fundamental Requirements** The fundamental requirements, also known as functional requirements, are the cornerstone of the system analysis phase. They define the specific behaviors, functions, and operations that the SmartPark system must be capable of performing to meet the needs of its users and achieve its objectives. These requirements are derived from the project's purpose and scope and serve as a definitive checklist for the development and testing teams. They answer the question: "What must the system do?" The functional requirements for the SmartPark system are categorized by module for clarity. **FR-1: User Account and Profile Management** * **FR-1.1 (User Registration):** The system shall provide a public-facing web page where a new user can create a personal account by providing a full name, a unique email address, and a secure password. * **FR-1.2 (Password Security):** The system must not store user passwords in plain text. It shall use a strong, one-way cryptographic hashing algorithm with a unique salt for each user (e.g., bcrypt) to store password hashes in the **MSSQL** database. * **FR-1.3 (User Authentication):** The system shall provide a secure login page where registered users can authenticate themselves using their email and password. Upon successful authentication, the system shall grant them access to their personalized dashboard. * **FR-1.4 (Profile Management):** After logging in, a user must be able to view and update their personal profile information, such as their full name and contact details. * **FR-1.5 (Vehicle Management):** A logged-in user must have the ability to add one or more vehicles to their profile. For each vehicle, they must specify the license number plate and the vehicle type (e.g., Car, Bike, Van). * **FR-1.6 (Vehicle Modification):** Users must be able to edit the details of their saved vehicles or delete them from their profile at any time. **FR-2: Parking Booking and Availability Subsystem** * **FR-2.1 (Real-time Availability Display):** The system's public web portal must display the number of currently available parking slots, clearly categorized by vehicle type. * **FR-2.2 (Live Update):** The availability count displayed on the portal must be updated in near real-time, automatically decrementing when a car enters and incrementing when a car exits. * **FR-2.3 (Advance Booking):** A logged-in user must be able to initiate a booking process. This process must allow the user to select one of their registered vehicles, a desired entry date, and an entry time. * **FR-2.4 (Overbooking Prevention):** The system must have logic to prevent overbooking. It shall only allow a booking to be confirmed if a slot for the selected vehicle type is projected to be available at the requested time. * **FR-2.5 (Booking Confirmation):** The system must provide the user with an instant on-screen and/or email confirmation upon the successful completion of a booking and payment. * **FR-2.6 (Booking History):** The user's dashboard must contain a section where they can view a history of their past bookings and details of their upcoming, active bookings. **FR-3: Payment Processing Module** * **FR-3.1 (Payment Gateway Integration):** The system must be fully integrated with the **Stripe** payment gateway to securely process all online payments for advance bookings. * **FR-3.2 (Fee Calculation):** The system must be able to calculate the appropriate fee for a booking based on predefined rates, which may vary by vehicle type or duration. * **FR-3.3 (Secure Transaction Handling):** The system must securely redirect the user to Stripe's hosted payment environment to enter their financial details. At no point shall the SmartPark system's servers store or have access to raw credit card numbers or other sensitive financial data. * **FR-3.4 (Transaction Logging):** The system must listen for and process webhook notifications from Stripe to reliably record the final transaction status (e.g., 'succeeded', 'failed') in the local **MSSQL** database and associate it with the correct booking record. **FR-4: Autonomous Entry and Exit Control Module** * **FR-4.1 (ANPR Data Reception - Entry):** The system must provide a secure API endpoint that can be called by the ANPR camera system at the parking facility's entrance, passing the recognized number plate data. * **FR-4.2 (Entry Validation):** Upon receiving a number plate at the entry point, the backend system must execute a validation workflow: * First, check for a valid, active pre-booking for that number plate. * If no booking exists, check for real-time slot availability for a drive-in user. * **FR-4.3 (Entry Access Control):** Based on the validation outcome, the system must be able to signal the physical barrier gate system to either open (if access is granted) or remain closed (if access is denied). * **FR-4.4 (ANPR Data Reception - Exit):** The system must provide a similar secure API endpoint for the ANPR camera at the exit to report a departing vehicle's number plate. * **FR-4.5 (Session Finalization):** Upon receiving a number plate at the exit, the system must locate the active parking session, calculate the total duration and any outstanding fees, and verify that the session is fully paid. * **FR-4.6 (Exit Access Control):** The system must signal the exit barrier to open only after the parking session has been successfully closed and settled. * **FR-4.7 (Slot De-allocation):** Upon a vehicle's confirmed exit, the system must immediately mark the corresponding parking slot as vacant and update the public availability count. **FR-5: Administrative Functions Module** * **FR-5.1 (Secure Admin Access):** The system must provide a separate, secure login interface for authorized administrative personnel. Access must be restricted based on predefined roles. * **FR-5.2 (Real-time Dashboard):** The administrative dashboard must provide a real-time, at-a-glance overview of the parking facility's status, including total capacity, current occupancy, available slots per vehicle type, and key financial metrics for the current day. * **FR-5.3 (User Management):** Administrators must have the functionality to search for, view the details of, and manage any registered user account in the system. * **FR-5.4 (Session and Transaction Monitoring):** Administrators must be able to view a detailed log of all parking sessions and financial transactions that have occurred in the system. * **FR-5.5 (Reporting):** The system must allow administrators to generate, view, and potentially export basic historical reports, such as daily, weekly, or monthly revenue summaries. These fundamental requirements collectively define the complete functional scope of the SmartPark project, providing a clear blueprint for the development and testing phases. [PAGE BREAK] ### **3.2 System Non-Fundamental Requirements** Non-fundamental, or non-functional, requirements (NFRs) are critical for the success of the system as they define its quality attributes and operational characteristics. While functional requirements describe *what* the system does, NFRs describe *how well* the system performs these functions. They encompass aspects like performance, security, reliability, and usability, which directly impact user satisfaction and the system's overall viability. #### **3.2.1 Performance** Performance is a measure of the system's speed, responsiveness, and ability to handle load. For a real-time system like SmartPark, high performance is not a luxury but a necessity to prevent physical queues and ensure a smooth user experience. * **NFR-1.1 (Web Portal Response Time):** All user-facing web pages, including the dashboard, booking forms, and information pages, must render completely in the user's browser in under 3 seconds over a standard internet connection. * **NFR-1.2 (API Latency):** The server-side processing time for any given API request from the client should ideally be under 200 milliseconds, and must not exceed 500 milliseconds under normal load, to ensure the web application feels snappy and responsive. * **NFR-1.3 (ANPR Processing Latency):** This is a critical performance metric. The total time elapsed from the ANPR camera capturing a vehicle's number plate to the backend system processing the data and sending an "open" or "close" command to the barrier gate controller must be less than 2 seconds. Any longer risks creating a bottleneck and negating the benefits of automation. * **NFR-1.4 (Concurrent User Load):** The system architecture, including the web server and the **MSSQL** database, must be capable of handling a load of at least 50 concurrent users interacting with the web portal simultaneously without any noticeable degradation in performance or response times. * **NFR-1.5 (Database Query Optimization):** All database queries, especially those executed frequently (like checking slot availability, validating a booking, or fetching a user's session), must be highly optimized. The use of proper indexing on the **MSSQL** tables is mandatory to ensure these queries execute in well under 100 milliseconds. * **NFR-1.6 (Real-time Update Latency):** The time between a vehicle exiting the facility and the public-facing availability count being updated on the web portal must be less than 5 seconds. [PAGE BREAK] #### **3.2.2 Security** Security is the most critical non-functional requirement for the SmartPark system, as it handles personal user data and is connected to a financial payment gateway. The system must be architected with a security-first mindset to protect against threats and build user trust. * **NFR-2.1 (Data Encryption in Transit):** All communication channels must be secured. Data transmitted between the user's browser and the web server, and between the web server and third-party APIs like **Stripe** and the ANPR service, must be encrypted using the Transport Layer Security (TLS) protocol (i.e., served over HTTPS). This prevents eavesdropping and man-in-the-middle attacks. * **NFR-2.2 (Data Encryption at Rest):** Sensitive data stored within the **MSSQL** database must be protected. Specifically, user passwords must never be stored in plain text. They must be passed through a strong, one-way cryptographic hashing function with a randomly generated salt for each user. Bcrypt is the chosen algorithm for this purpose. * **NFR-2.3 (Authentication and Authorization):** The system must implement robust authentication mechanisms to verify the identity of all users and administrators. Furthermore, a strong authorization layer, such as Role-Based Access Control (RBAC), must be implemented. This ensures that regular users can only access their own data, while administrators can only access the functions and data permitted by their specific role. * **NFR-2.4 (Prevention of Common Web Vulnerabilities):** The application must be developed using defensive coding practices to mitigate the risks of common security threats as outlined by the OWASP Top 10. This includes: * **SQL Injection:** Prevented by the exclusive use of parameterized queries, which is a default behavior of the Entity Framework ORM. * **Cross-Site Scripting (XSS):** Prevented by properly encoding all user-supplied data before it is rendered back onto a web page. * **Cross-Site Request Forgery (CSRF):** Prevented by implementing anti-forgery tokens in all forms that perform state-changing actions. * **NFR-2.5 (Secure Payment Handling):** To ensure maximum security and legal compliance, the system must delegate all handling of sensitive cardholder data to the **Stripe** payment gateway. The SmartPark servers will never store, process, or transmit raw credit card numbers, CVC codes, or expiration dates. This offloads the burden of PCI-DSS compliance to Stripe. * **NFR-2.6 (Secure Configuration):** The production server environment must be securely configured. This includes disabling unnecessary services and ports, using a firewall, and ensuring that all software components, including the operating system, **.NET Framework**, and **MSSQL Server**, are kept up-to-date with the latest security patches. [PAGE BREAK] #### **3.2.3 Reliability** Reliability is the measure of a system's ability to perform its required functions correctly and consistently over a period of time. For an autonomous system controlling physical access, reliability is crucial for maintaining operational continuity and user trust. * **NFR-3.1 (System Uptime):** The SmartPark system, including the web portal and backend APIs, should be operational and available to users 99.5% of the time. This allows for approximately 43 hours of downtime per year, which should be reserved for scheduled maintenance. * **NFR-3.2 (Fault Tolerance and Graceful Degradation):** The system must be resilient to partial failures. For example: * If the connection to the **Stripe** API is temporarily unavailable, the system should not crash. It should disable the booking button and display a user-friendly message like, "Online payments are temporarily unavailable. Please try again later." * In the event of an ANPR camera malfunction, the system must provide a mechanism for an administrator to manually override the barrier gate via the admin dashboard to prevent vehicles from being trapped. * If a database query fails, the system should log the error and present a generic error page to the user rather than exposing raw exception details. * **NFR-3.3 (Data Integrity):** The system must use database transactions for all operations that involve multiple, related database writes. For example, when a booking is made, the creation of the `Booking` record and the `Payment` record should be wrapped in a single transaction. This ensures that if one part of the operation fails, the entire operation is rolled back, leaving the database in a consistent state. * **NFR-3.4 (Data Backup and Recovery):** A robust backup strategy must be in place for the **MSSQL** database to prevent data loss in the event of hardware failure or data corruption. This strategy should include regular, automated full backups (e.g., weekly) and incremental or differential backups (e.g., daily). The backups must be stored in a secure, off-site location. A recovery plan must also be documented and tested to ensure data can be restored within a defined Recovery Time Objective (RTO). * **NFR-3.5 (Transactional Reliability):** The system must ensure that no booking or payment transaction is lost. The use of Stripe webhooks provides a reliable mechanism for this. Even if the user closes their browser after paying, the webhook will notify the backend, ensuring the booking is confirmed correctly. [PAGE BREAK] #### **3.2.4 Scalability** Scalability refers to the system's ability to handle a growing amount of work or its potential to be enlarged to accommodate that growth. The architecture of SmartPark must be designed not just for current needs but also for future expansion. * **NFR-4.1 (Vertical Scalability):** The system should be able to take advantage of increased resources on a single server. For example, if the RAM or CPU of the web server is upgraded, the application's performance should improve accordingly. This means the application should not have artificial bottlenecks that prevent it from using available resources. * **NFR-4.2 (Horizontal Scalability - Load Balancing):** The architecture must support horizontal scaling. This means the **.NET** web application should be stateless, allowing it to be deployed across multiple web servers behind a load balancer. This is the primary method for handling a massive increase in user traffic. All session state must be managed client-side (e.g., via JWT) or in a distributed cache. * **NFR-4.3 (Database Scalability):** The **MSSQL** database must be designed to handle a growing volume of data over time without a linear degradation in performance. This will be achieved through: * **Proper Indexing:** Creating appropriate indexes on table columns that are frequently used in `WHERE` clauses or `JOIN` conditions to speed up query execution. * **Query Optimization:** Regularly analyzing and optimizing complex queries. * **Read Replicas:** For very high-read scenarios in the future, the architecture could be extended to use database read replicas, where read queries are directed to a copy of the database, reducing the load on the primary write database. * **NFR-4.4 (Geographic and Functional Scalability):** The system's design should not be so rigid as to prevent future expansion. * **Multi-Facility Support:** The database schema should include identifiers (e.g., `LocationID`, `FacilityID`) in tables like `ParkingSlots` and `Bookings`. Even if not used in the initial version, this will make it vastly easier to adapt the system to manage multiple parking lot locations in the future. * **Modular Design:** The use of a modular architecture (as described in Section 1.8) means that new features or modules can be added in the future with minimal impact on the existing, stable codebase. [PAGE BREAK] #### **3.2.5 Usability** Usability is the measure of the quality of a user's experience when interacting with the system. A system can be functionally perfect and highly performant, but if it is difficult or frustrating to use, it will be considered a failure by its end-users. * **NFR-5.1 (Learnability and Intuitiveness):** A first-time user should be able to navigate the web portal and accomplish primary tasks (e.g., registering, booking a slot) without needing to consult a help manual or tutorial. The system's design will achieve this by following established web design conventions, using clear and consistent labeling, and creating a logical information architecture. * **NFR-5.2 (Efficiency of Use):** Once a user is familiar with the system, they should be able to perform frequent tasks quickly. The process of making a booking, for a returning user who is logged in, should be completable in a minimal number of clicks and steps (ideally, five or fewer). * **NFR-5.3 (User Feedback and Error Prevention):** The system must provide clear, timely, and understandable feedback to the user. * **Positive Feedback:** After a successful action (e.g., "Booking Confirmed! An email has been sent."). * **Error Prevention:** The system should use client-side validation (using **JavaScript**) to prevent users from submitting forms with invalid data (e.g., an improperly formatted email address). * **Constructive Error Messages:** When an error does occur, the message should be clear and helpful (e.g., "This email address is already registered. Please try logging in instead.") rather than a generic "An error occurred." * **NFR-5.4 (Accessibility):** The web portal should adhere to the Web Content Accessibility Guidelines (WCAG) 2.1 at the 'AA' level where feasible. This includes practices like providing alternative text for all images, ensuring sufficient color contrast between text and its background, making all functionality accessible via the keyboard, and using proper semantic HTML tags to assist screen readers. * **NFR-5.5 (Responsive Design):** The user interface must be fully responsive and provide an optimal, seamless experience across a wide range of devices and screen sizes. The layout, navigation, and content must adapt gracefully whether the user is on a large desktop monitor, a laptop, a tablet, or a small smartphone screen. This will be a primary focus during frontend development using **Bootstrap** and **Tailwind CSS**. [PAGE BREAK] ### **3.3 Hardware and Software Requirements** This section provides a detailed specification of the necessary hardware and software components required for the successful development, deployment, and operation of the SmartPark system. These requirements ensure that the system has a stable and capable environment in which to run. #### **3.3.1 Hardware Requirements** The hardware requirements are logically divided into the server-side infrastructure that will host the application, the on-site equipment needed at the physical parking facility, and the standard hardware required by end-users. **A. Server-Side Hardware (Deployment Environment)** This describes the minimum recommended specifications for the server(s) that will run the SmartPark application in a live environment. * **Application Server (Hosting the .NET Web API):** * **Processor:** A modern multi-core 64-bit processor (e.g., Intel Xeon E-2224 3.4GHz Quad-Core or equivalent). A higher core count and clock speed will improve the server's ability to handle concurrent requests. * **Memory (RAM):** A minimum of 8 GB DDR4 ECC RAM. 16 GB is strongly recommended to provide ample memory for the .NET runtime, the web server process (IIS), and the operating system, ensuring smooth performance under moderate traffic. * **Storage:** A minimum of 100 GB of high-speed storage, preferably a Solid State Drive (SSD), for the operating system and the deployed application files. SSDs provide significantly faster read/write speeds compared to traditional HDDs, which improves application startup and response times. * **Network Interface:** A 1 Gbps network interface card (NIC) connected to a high-speed, reliable internet connection with a static public IP address. * **Database Server (Hosting MSSQL):** * **Processor:** A multi-core 64-bit processor, similar to the application server. Database performance is often I/O and memory bound, but a capable CPU is still essential. * **Memory (RAM):** A minimum of 8 GB DDR4 ECC RAM. For a database server, more memory is almost always better. 16 GB or 32 GB is recommended as **MSSQL** will use available memory for caching data and execution plans, which dramatically speeds up query performance. * **Storage:** A minimum of 200 GB of high-performance SSD storage. The storage should be configured in a redundant array (e.g., RAID 1 or RAID 10) to protect against data loss from a single drive failure. Storage capacity needs will grow over time as more data is collected. * **Network Interface:** A 1 Gbps NIC. For optimal performance, the database server should be on the same high-speed local network as the application server to minimize query latency. **B. On-Site Hardware (At the Parking Facility)** * **ANPR Cameras:** Industrial-grade IP-based cameras specifically designed for license plate recognition. These cameras must have: * High resolution (minimum 1920x1080 / 1080p). * Infrared (IR) illuminators for effective night-time operation. * A fast shutter speed to capture clear images of moving vehicles. * Network connectivity (Ethernet). At least one camera is required for each entry and exit lane. * **Barrier Gate System:** Commercial-grade automated boom barriers. The controller for these barriers must have an interface (e.g., dry contact relays, network API) that can be triggered by an electrical or network signal from the SmartPark control system. * **Administrator Workstation:** A standard office desktop or laptop computer with a modern web browser and a reliable connection to the internet or local network to access the administrative dashboard. **C. Client-Side Hardware (End Users)** * **Device:** Any modern computing device, including desktop computers, laptops, tablets (e.g., iPad, Android tablets), or smartphones (e.g., iPhone, Android phones), that is capable of running a standard, up-to-date web browser. [PAGE BREAK] #### **3.3.2 Software Requirements** This section details the specific software, frameworks, and tools required for both the development and production environments of the SmartPark system. **A. Development Environment** This is the suite of tools that will be used by the project team to build and test the application. * **Operating System:** Windows 10 Pro (64-bit) or Windows 11 Pro (64-bit). * **Integrated Development Environment (IDE):** **Microsoft Visual Studio 2022** (the free Community Edition is sufficient for this project, although Professional or Enterprise editions offer more advanced features). This will be the primary tool for writing, debugging, and compiling the **C#/.NET** backend code. * **Core Framework:** **.NET Framework 4.8** or a more modern version like .NET 6/7. * **Programming Language:** **C#** (version 9.0 or later). * **Database System:** **Microsoft SQL Server 2019 Developer Edition** (which is free and has all the features of the Enterprise edition for development purposes) or **SQL Server 2019 Express Edition**. * **Database Management Tool:** **SQL Server Management Studio (SSMS)** version 18 or later. This is the primary tool for designing the database, running queries, and managing data during development. * **Web Development Tools:** * A modern web browser with built-in developer tools, such as Google Chrome, Mozilla Firefox, or Microsoft Edge. * A lightweight code editor like **Visual Studio Code** for focused frontend development (**HTML, CSS, JavaScript, Tailwind CSS**). * **Version Control System:** **Git**. A local Git client must be installed, and a remote repository will be hosted on a service like GitHub or Azure DevOps for source code management and collaboration. * **API Testing Tool:** **Postman**. This tool is essential for simulating requests from the ANPR camera system and for testing the backend API endpoints independently of the frontend UI. **B. Server-Side Software (Production/Deployment Environment)** This is the software stack that will be installed on the production servers to host the live application. * **Operating System:** **Windows Server 2016** (64-bit) or a later version (e.g., Windows Server 2019 or 2022). * **Web Server:** **Internet Information Services (IIS)** version 10 or later. It must be configured with the **ASP.NET Hosting Bundle** corresponding to the version of the .NET framework used in development. * **Database Server:** **Microsoft SQL Server 2019** (Standard Edition is recommended for production workloads, as it offers more performance and reliability features than the Express Edition). * **ANPR Software:** A third-party Automatic Number Plate Recognition software service. This software will be responsible for processing the video feed from the on-site cameras and making the API calls to the SmartPark backend. Its specific requirements will be determined by the chosen vendor. **C. Client-Side Software (End Users and Administrators)** * **Web Browser:** The latest stable release of any major, modern web browser. This includes, but is not limited to: * Google Chrome * Mozilla Firefox * Microsoft Edge * Apple Safari * **Configuration:** JavaScript and browser cookies must be enabled for the site to function correctly. No other plugins or special software installations are required for the end-users. [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] **CHAPTER NO 4 SYSTEM DESIGN** [PAGE BREAK] ### **4.1 Use Case Diagram** A Use Case diagram is a fundamental artifact in system design, originating from Unified Modeling Language (UML). It provides a high-level, graphical representation of a system's functionality by illustrating the interactions between external entities, known as "actors," and the functions provided by the system, known as "use cases." This diagram is invaluable for communicating the system's intended behavior to all stakeholders, including developers, clients, and end-users, without delving into the complexities of implementation details. For the SmartPark system, the Use Case diagram defines the boundaries of the system and clarifies who can do what. **Description of Diagram Components:** * **Actors:** These are the entities that interact with the SmartPark system. They can be human users or other external systems. We have identified four primary actors: * **User:** A primary human actor representing a vehicle owner or driver. This actor interacts with the public-facing web portal to manage their account and book parking. * **Administrator:** A primary human actor representing the parking facility staff. This actor has privileged access to the system's management and monitoring functions. * **ANPR Camera:** A secondary, non-human actor. It represents the automated camera system that provides the crucial input of number plate data to our system. * **Stripe Payment System:** A secondary, non-human actor. It represents the external payment gateway that processes all financial transactions. * **System Boundary:** This is a large rectangle that encloses all the use cases. It visually separates the internal workings of the "SmartPark System" from the external actors that interact with it. * **Use Cases:** These are represented by ovals within the system boundary. Each use case represents a specific, significant goal that an actor can achieve by interacting with the system. * **Relationships:** These are the lines that connect actors to use cases and use cases to each other, defining their interactions. * **Association:** A solid line between an actor and a use case indicates that the actor participates in that use case. * **Include (`<<include>>`):** An arrow pointing from a base use case to an included use case. This means the included use case's functionality is *always* executed as part of the base use case. For example, `Book Parking Slot` must `<<include>>` the `Login` use case. * **Extend (`<<extend>>`):** An arrow pointing from an extending use case to a base use case. This signifies that the extending use case's functionality is optional and only runs under certain conditions. For example, a `Request Password Reset` use case would `<<extend>>` the `Login` use case, but only when the user indicates they have forgotten their password. The diagram below provides a visual summary of these components and their interactions within the context of the SmartPark project. [PAGE BREAK] **Figure 4.1 Use Case Diagram** **(A visual diagram would be placed here based on the following description. This can be created in tools like Microsoft Visio, draw.io, or Lucidchart.)** * **Center:** A large rectangle labeled **SmartPark System**. * **Actors (outside the rectangle):** * A stick figure labeled **User** on the left. * A stick figure labeled **Administrator** on the right. * A box labeled **ANPR Camera** below the system boundary on the left. * A box labeled **Stripe Payment System** below the system boundary on the right. * **Use Cases (ovals inside the rectangle):** * **Top-left (User-facing):** `Register Account`, `Login`, `Manage Profile`, `View Slot Availability`, `Book Parking Slot`, `Make Payment`, `View Booking History`. * **Top-right (Admin-facing):** `Manage Users`, `View Occupancy Dashboard`, `Generate Reports`. * **Bottom (System-driven):** `Process Vehicle Entry`, `Process Vehicle Exit`. * **Lines and Relationships:** * The **User** actor has association lines to `Register Account`, `Login`, `Manage Profile`, `View Slot Availability`, `Book Parking Slot`, and `View Booking History`. * The **Administrator** actor has association lines to `Login`, `Manage Users`, `View Occupancy Dashboard`, and `Generate Reports`. * A dashed arrow with `<<include>>` goes from `Book Parking Slot` to `Login`. * Another dashed arrow with `<<include>>` goes from `Manage Profile` to `Login`. * The `Make Payment` use case has an association line to the **Stripe Payment System** actor. It also has a dashed arrow with `<<include>>` going from `Book Parking Slot` to `Make Payment`, indicating payment is a mandatory part of booking. * The **ANPR Camera** actor has association lines to `Process Vehicle Entry` and `Process Vehicle Exit`. [PAGE BREAK] **4.2 Use Cases** While the Use Case diagram provides a high-level map, detailed Use Case descriptions provide the narrative. They describe the step-by-step interactions between the actors and the system required to achieve a specific goal. The following tables provide these detailed descriptions for the most critical functionalities of the SmartPark system. #### **4.2.1 User Registration** **Table 4.1 Registration Use Case** | Field | Description | | :--- | :--- | | **Use Case ID** | UC-01 | | **Use Case Name** | User Registration | | **Actor(s)** | User (unregistered visitor) | | **Goal** | To create a new user account in the system to enable booking and other personalized features. | | **Trigger** | The user clicks on the "Register" or "Sign Up" link on the web portal's home page. | | **Preconditions** | The user must have a valid, unique email address and must be connected to the internet. | | **Postconditions** | **On Success:** A new user account is created and stored in the database. The user is redirected to the login page or their new dashboard with a success message. <br> **On Failure:** The user remains on the registration page with an appropriate error message displayed. No account is created. | | **Main Flow (Successful Path)** | 1. The user navigates to the registration page. <br> 2. The system displays a form requesting Full Name, Email Address, Password, and a Confirm Password field. <br> 3. The user fills in all the required fields with their details. <br> 4. The user clicks the "Register" button to submit the form. <br> 5. The system performs client-side validation (e.g., checks that passwords match and the email has a valid format). <br> 6. The form data is sent to the backend server. <br> 7. The backend server performs server-side validation again to ensure data integrity. <br> 8. The system checks the database to ensure the provided email address is not already registered. <br> 9. The system generates a strong, salted hash of the user's password using the bcrypt algorithm. <br> 10. The system saves the new user's information (name, email, password hash) to the `Users` table in the **MSSQL** database. <br> 11. The system redirects the user to the login page and displays a "Registration Successful" message. | | **Alternate Flows (Exceptions)** | **5a. Client-Side Validation Failure:** If client-side validation fails (e.g., passwords do not match), the form is not submitted, and an error message is displayed next to the relevant field in real-time. <br> **8a. Email Already Exists:** If the system finds that the email address is already in use, it returns an error to the user, "An account with this email address already exists. Please log in." The process terminates. | [PAGE BREAK] #### **4.2.2 User Login** **Table 4.2 Login Use Case** | Field | Description | | :--- | :--- | | **Use Case ID** | UC-02 | | **Use Case Name** | User Login | | **Actor(s)** | User (registered), Administrator | | **Goal** | To securely authenticate a user and grant them access to their role-specific dashboard and protected features. | | **Trigger** | The user navigates to the "Login" or "Sign In" page. | | **Preconditions** | The user must have a previously registered and active account. | | **Postconditions** | **On Success:** The user is authenticated, a session token is generated, and they are redirected to their main dashboard. <br> **On Failure:** The user remains on the login page with an error message. Access is denied. | | **Main Flow (Successful Path)** | 1. The user navigates to the login page. <br> 2. The system displays a form requesting their Email Address and Password. <br> 3. The user enters their credentials and clicks the "Login" button. <br> 4. The credentials are securely sent to the backend server. <br> 5. The backend searches the `Users` (or `Admins`) table in the database for a record matching the provided email address. <br> 6. If a user is found, the system retrieves their stored password hash. <br> 7. The system uses the bcrypt algorithm to compare the plaintext password submitted by the user with the stored hash. <br> 8. The comparison is successful. The system generates a JSON Web Token (JWT) containing the user's ID and role, signed with a secret key. <br> 9. The system sends this JWT back to the user's browser, which stores it for subsequent requests. <br> 10. The system redirects the user to their role-appropriate dashboard (User Dashboard or Admin Dashboard). | | **Alternate Flows (Exceptions)** | **5a. User Not Found:** If no user account is found for the email provided in step 5, the system returns a generic error message, "Invalid email or password." It does not specify that the email was not found, to prevent account enumeration attacks. <br> **7a. Incorrect Password:** If the password comparison in step 7 fails, the system returns the same generic error message, "Invalid email or password." <br> **3a. Brute Force Attempt:** If multiple failed login attempts are detected from the same IP address in a short period, the system can temporarily lock out further attempts from that IP to mitigate brute-force attacks. | [PAGE BREAK] #### **4.2.3 Advance Slot Booking** **Table 4.3 Advance Slot Booking Use Case** | Field | Description | | :--- | :--- | | **Use Case ID** | UC-03 | | **Use Case Name** | Advance Slot Booking | | **Actor(s)** | User (logged-in) | | **Secondary Actor(s)**| Stripe Payment System | | **Goal** | To allow a user to reserve a guaranteed parking spot for a specific vehicle at a future time and pay for it securely online. | | **Trigger** | The user clicks on the "Book a Slot" or "New Booking" button within their dashboard. | | **Preconditions** | The user must be successfully logged into the system. The user must have at least one vehicle registered in their profile. | | **Postconditions** | **On Success:** A new booking record is created in the database with a "Confirmed" status. A payment record is created. The user receives a confirmation. <br> **On Failure:** No booking is made. The user is informed of the failure (e.g., payment declined). | | **Main Flow (Successful Path)** | 1. The user navigates to the booking page. <br> 2. The system displays an intuitive form for creating a new booking. The form is pre-populated with a dropdown list of the user's registered vehicles. <br> 3. The user selects a vehicle, a desired entry date, and an entry time from a calendar/time-picker widget. <br> 4. The user clicks "Proceed to Payment". <br> 5. The backend system creates a preliminary booking record (with a 'Pending' status) and generates a payment request (a Payment Intent) for the **Stripe Payment System**. <br> 6. The system securely redirects the user to the Stripe Checkout page, passing the Payment Intent ID. <br> 7. The user enters their credit/debit card information directly on the secure Stripe page and confirms the payment. <br> 8. Stripe processes the payment and redirects the user back to a pre-configured "Success" URL on the SmartPark portal, providing a token indicating the transaction's success. <br> 9. The SmartPark backend receives this confirmation (often via a more reliable webhook) and verifies the transaction with Stripe. <br> 10. The system updates the booking record's status in the **MSSQL** database from "Pending" to "Confirmed" and saves the Stripe transaction ID in the `Payments` table. <br> 11. The system displays a "Booking Confirmed" page to the user with all relevant details and sends a confirmation email. | | **Alternate Flows (Exceptions)** | **9a. Payment Declined/Failed:** If Stripe cannot process the payment, it redirects the user back to a "Failure" URL on the SmartPark portal. The system displays a "Payment Failed" message, and the 'Pending' booking record is marked as "Cancelled" or deleted. | [PAGE BREAK] #### **4.2.4 Autonomous Check-in** **Table 4.4 Autonomous Check-in Use Case** | Field | Description | | :--- | :--- | | **Use Case ID** | UC-04 | | **Use Case Name** | Autonomous Check-in | | **Actor(s)** | ANPR Camera | | **Goal** | To automatically identify a vehicle at the entrance, validate its right to enter, and grant access without human intervention. | | **Trigger** | A vehicle approaches the entrance barrier, entering the ANPR camera's field of view. | | **Preconditions** | The ANPR camera, barrier gate system, and network are all operational. The SmartPark backend server is running and accessible. | | **Postconditions** | **On Success:** The vehicle's entry is logged as a new parking session, the barrier gate opens, and the lot occupancy is updated. <br> **On Failure:** The barrier gate remains closed. | | **Main Flow (Pre-Booked Vehicle)** | 1. The **ANPR Camera** captures an image of the vehicle's license plate. The ANPR software extracts the number plate string and sends it via a secure API call to the SmartPark backend's entry endpoint. <br> 2. The backend system receives the number plate. <br> 3. The system queries the `Bookings` table in the **MSSQL** database for a valid, 'Confirmed' booking corresponding to the number plate for the current date and a time window around the current time. <br> 4. A valid booking is found. The system creates a new record in the `ParkingSessions` table, linking it to the booking and recording the exact entry time. <br> 5. The system sends an "Open" command to the barrier gate controller. <br> 6. The system updates the `ParkingSlots` status to decrement the available count. | | **Main Flow (Drive-in Vehicle)** | 1. The **ANPR Camera** captures and sends the number plate to the backend (Steps 1-2). <br> 2. The system queries the `Bookings` table and finds no active booking for the number plate. <br> 3. The system then queries the `ParkingSlots` table to check the real-time availability of slots for that vehicle type. <br> 4. A slot is determined to be available. The system creates a new record in the `ParkingSessions` table with the number plate and the current entry time. <br> 5. The system sends an "Open" command to the barrier gate controller. <br> 6. The system updates the `ParkingSlots` status. | | **Alternate Flows (Exceptions)** | **4a. Drive-in Vehicle, Lot Full:** If the system determines in step 3 of the drive-in flow that there are no available slots, it logs the entry attempt but does not create a session. The system does not send an "Open" command. It might trigger an external display to show a "Lot Full" message. | [PAGE BREAK] #### **4.2.5 Autonomous Check-out** **Table 4.5 Autonomous Check-out Use Case** | Field | Description | | :--- | :--- | | **Use Case ID** | UC-05 | | **Use Case Name** | Autonomous Check-out | | **Actor(s)** | ANPR Camera | | **Goal** | To automatically identify a departing vehicle, finalize its parking session, ensure payment is settled, and grant exit. | | **Trigger** | A vehicle approaches the exit barrier, entering the ANPR camera's field of view. | | **Preconditions** | The vehicle must have an active parking session in the system. The exit ANPR camera and barrier gate must be operational. | | **Postconditions** | **On Success:** The parking session is closed, the barrier gate opens, and the slot availability is updated. <br> **On Failure:** The barrier gate remains closed. | | **Main Flow (Successful Path)** | 1. The **ANPR Camera** at the exit captures the vehicle's license plate and sends it to the SmartPark backend's exit endpoint. <br> 2. The backend system receives the number plate. <br> 3. The system queries the `ParkingSessions` table to find the currently active session for that number plate. <br> 4. The system retrieves the entry time from the session record and calculates the total parking duration. <br> 5. The system calculates the total fee based on the duration and predefined rate structure. <br> 6. The system checks the payment status. For a pre-paid booking, this is already settled. For a drive-in user, the system would check if payment has been made (e.g., via a mobile app payment or kiosk). <br> 7. The payment is confirmed as settled. The system updates the `ParkingSessions` record, filling in the `ExitTime` and `TotalFee`. <br> 8. The system sends an "Open" command to the exit barrier gate controller. <br> 9. The system updates the `ParkingSlots` status, incrementing the available slot count for that vehicle type. | | **Alternate Flows (Exceptions)** | **6a. Payment Not Settled:** If the system determines there is an outstanding balance for a drive-in user, it does not open the barrier. Instead, it would signal an external display to show the amount due and direct the user to a payment method (e.g., "Payment Due: $12. Please pay via the app."). The barrier remains closed until the system receives a payment confirmation for that session. | [PAGE BREAK] #### **4.2.6 Admin Dashboard Access** **Table 4.6 Admin Dashboard Access Use Case** | Field | Description | | :--- | :--- | | **Use Case ID** | UC-06 | | **Use Case Name** | Admin Dashboard Access | | **Actor(s)** | Administrator | | **Goal** | To provide a centralized, secure interface for the administrator to monitor real-time operations, manage users, and view reports. | | **Trigger** | The administrator navigates to the unique, non-public admin login URL. | | **Preconditions** | The administrator must have a valid, pre-assigned admin account with a username and password. | | **Postconditions** | The administrator can view and perform management tasks according to their assigned permissions. Session is terminated upon logout. | | **Main Flow (Example: Viewing Operations)** | 1. The administrator successfully logs into the system using their credentials (following a flow similar to UC-02, but checking the `Admins` table). <br> 2. The system verifies the user has administrator privileges and redirects them to the main Admin Dashboard. <br> 3. The dashboard immediately displays key real-time metrics fetched from the database: a graphical chart of total capacity vs. current occupancy, the number of available slots per vehicle type, and total revenue collected for the current day. <br> 4. The administrator navigates to the "Manage Users" section. The system displays a searchable and paginated list of all registered users. <br> 5. The administrator searches for a specific user by email. The system filters the list and displays the matching user's detailed profile, including their vehicles and booking history. <br> 6. The administrator navigates to the "Live Sessions" section. The system displays a table of all vehicles currently inside the facility, showing their number plate and entry time. <br> 7. The administrator navigates to the "Reports" section and generates a revenue report for the previous month. The system queries the `Payments` table, aggregates the data, and displays a summary report. <br> 8. The administrator clicks the "Logout" button, which invalidates their session token and redirects them to the admin login page. | | **Alternate Flows (Exceptions)** | **1a. Unauthorized Access Attempt:** If a regular user (or an unauthenticated user) attempts to access any URL within the `/admin` path, the system's authorization middleware will intercept the request, deny access, and redirect them to the standard user login page or a "403 Forbidden" error page. | [PAGE BREAK] **4.3 System Sequence Diagram** A sequence diagram is a powerful UML tool that illustrates object interactions arranged in a time sequence. It depicts the objects involved in a scenario and the sequence of messages exchanged between them to carry out the functionality of the scenario. Below are textual descriptions of the sequence diagrams for the most important processes in the SmartPark system. **Sequence Diagram: User Advance Booking and Payment** This diagram shows the detailed, step-by-step message flow when a user books a slot in advance. It highlights the crucial interaction with the external Stripe payment system. * **Objects:** * `:User` (The human actor) * `:BookingPage (Browser)` (The user's web browser) * `:BookingController (API)` (The backend endpoint in our .NET application) * `:StripeService` (A service class in our backend that encapsulates Stripe logic) * `:StripeAPI` (The external Stripe servers) * `:Database (MSSQL)` (Our project's database) * **Sequence of Messages:** 1. The `:User` fills out the booking form on the `:BookingPage` and clicks "Proceed to Pay". 2. The `:BookingPage` sends a `POST /api/bookings/create` request containing the booking details (vehicleId, time) to the `:BookingController`. 3. The `:BookingController` calls the `CreatePaymentIntent(amount)` method on its internal `:StripeService` component. 4. The `:StripeService` makes a secure, server-to-server API call to the `:StripeAPI` to create a new payment intent. 5. The `:StripeAPI` validates the request, creates the payment intent, and returns a unique `clientSecret` to the `:StripeService`. 6. The `:StripeService` returns this `clientSecret` to the `:BookingController`. 7. The `:BookingController` sends a success response back to the `:BookingPage`, containing the `clientSecret`. 8. The `:BookingPage`, using Stripe's JavaScript library (Stripe.js), uses the `clientSecret` to securely redirect the `:User` to the Stripe-hosted payment page. The user's browser is now interacting directly and securely with Stripe's servers. 9. The `:User` enters their card details and confirms the payment on the Stripe page. 10. The `:StripeAPI` processes the payment. Upon success, it sends an asynchronous `payment_intent.succeeded` webhook notification to a pre-configured endpoint on our `:BookingController`. This is a reliable server-to-server communication. 11. The `:BookingController` receives and verifies the webhook. It extracts the payment information. 12. The `:BookingController` then makes calls to the `:Database (MSSQL)` to `UPDATE` the corresponding booking's status to 'Confirmed' and `INSERT` a new record into the `Payments` table. 13. The user, having been redirected back to a success page on our site, sees a confirmation message. **Figure 4.2 Sequence Diagram of Advance Booking** *(A visual diagram would be placed here based on the description above.)* [PAGE BREAK] **Sequence Diagram: Autonomous Vehicle Check-in (Pre-Booked)** This diagram illustrates the rapid, fully automated check-in process for a user who has already booked and paid online. * **Objects:** * `:Vehicle` (The physical car, bike, or van) * `:ANPRCamera` (The camera system at the entrance) * `:ParkingController (API)` (Our .NET backend endpoint) * `:BookingRepository` (A data access class for booking-related queries) * `:SessionRepository` (A data access class for session-related queries) * `:Database (MSSQL)` (Our database) * `:BarrierGate` (The physical barrier) * **Sequence of Messages:** 1. The `:Vehicle` arrives at the entrance of the parking facility. 2. The `:ANPRCamera` captures the license plate, processes it, and sends a `POST /api/parking/entry` request with the `plateNumber` in the body to the `:ParkingController`. 3. The `:ParkingController` receives the incoming request. 4. It immediately calls the `FindActiveBooking(plateNumber, currentTime)` method on the `:BookingRepository`. 5. The `:BookingRepository` constructs and executes a `SELECT` query on the `:Database (MSSQL)` to find a 'Confirmed' booking for that plate. 6. The `:Database (MSSQL)` returns the booking record to the `:BookingRepository`. 7. The `:BookingRepository` returns the found booking object to the `:ParkingController`. 8. The `:ParkingController`, having confirmed a valid booking, now calls the `CreateSessionFromBooking(booking)` method on the `:SessionRepository`. 9. The `:SessionRepository` executes an `INSERT` command into the `ParkingSessions` table in the `:Database (MSSQL)`, recording the entry time and linking it to the booking. 10. The `:Database (MSSQL)` confirms the successful insertion. 11. The `:ParkingController` sends a final `Open()` message/signal to the `:BarrierGate`. 12. The `:BarrierGate` opens, allowing the `:Vehicle` to proceed into the facility. **Figure 4.3 Sequence Diagram of Autonomous Check-in** *(A visual diagram would be placed here based on the description above.)* [PAGE BREAK] **4.4 Class Diagram** A Class Diagram is a static structure diagram from UML that provides a blueprint of the system. It describes the structure by showing the system's classes, their attributes (fields), operations (methods), and the relationships between the classes. This diagram is essential for developers to understand the software's architecture before writing code. **(Description for creating a Class Diagram using a drawing tool)** **Core Entity Classes (Representing Database Tables):** * **`User`** * **Attributes:** `- UserID: int {PK}`, `- FullName: string`, `- Email: string {unique}`, `- PasswordHash: string`, `- CreatedAt: DateTime` * **Relationships:** Has a one-to-many relationship with `Vehicle` and `Booking`. * **`Vehicle`** * **Attributes:** `- VehicleID: int {PK}`, `- UserID: int {FK}`, `- NumberPlate: string {unique}`, `- VehicleType: string` * **Relationships:** Belongs to one `User`. * **`Booking`** * **Attributes:** `- BookingID: int {PK}`, `- UserID: int {FK}`, `- VehicleID: int {FK}`, `- BookingTime: DateTime`, `- ExpectedEntryTime: DateTime`, `- Status: string` * **Relationships:** Belongs to one `User` and is for one `Vehicle`. Has a one-to-one relationship with `Payment`. * **`Payment`** * **Attributes:** `- PaymentID: int {PK}`, `- BookingID: int {FK}`, `- Amount: decimal`, `- StripeTransactionID: string`, `- PaymentStatus: string`, `- PaymentDate: DateTime` * **`ParkingSession`** * **Attributes:** `- SessionID: int {PK}`, `- NumberPlate: string`, `- SlotID: int {FK}`, `- EntryTime: DateTime`, `- ExitTime: DateTime?`, `- TotalFee: decimal?` * **`ParkingSlot`** * **Attributes:** `- SlotID: int {PK}`, `- SlotNumber: string`, `- VehicleType: string`, `- IsOccupied: bool` * **`Admin`** * **Attributes:** `- AdminID: int {PK}`, `- Username: string {unique}`, `- PasswordHash: string`, `- Role: string` **Controller Classes (Handling API Requests):** * **`UserController`** * **Methods:** `+ Register(RegisterDto): IActionResult`, `+ Login(LoginDto): IActionResult`, `+ GetProfile(): IActionResult` * **`BookingController`** * **Methods:** `+ GetAvailability(): IActionResult`, `+ CreateBooking(BookingDto): IActionResult`, `+ HandleStripeWebhook(): IActionResult` * **`ParkingController`** * **Methods:** `+ ProcessEntry(PlateDto): IActionResult`, `+ ProcessExit(PlateDto): IActionResult` **Service/Repository Classes (Handling Business Logic and Data Access):** * **`AuthService`** * **Methods:** `+ RegisterUser(data)`, `+ AuthenticateUser(data): string` (returns JWT) * **`BookingService`** * **Methods:** `+ CreateNewBooking(data)`, `+ ConfirmBooking(transactionId)` * **`ParkingService`** * **Methods:** `+ HandleVehicleEntry(plate)`, `+ HandleVehicleExit(plate)` * **`StripeService`** * **Methods:** `+ CreatePaymentIntent(amount): string` * **`DbContext`** (Represents the database session from Entity Framework) * **Attributes:** `+ Users: DbSet<User>`, `+ Bookings: DbSet<Booking>`, etc. **Key Relationships between Classes:** * Controller classes have a dependency on (use) Service/Repository classes. (e.g., `BookingController` uses `BookingService` and `StripeService`). * Service/Repository classes have a dependency on the `DbContext` and the Entity classes. (e.g., `BookingService` uses the `DbContext` to query and save `Booking` objects). * Lines with arrows indicate dependency/usage. Lines with diamonds indicate composition/aggregation (e.g., `User` is composed of `Vehicles`). **Figure 4.4 Class Diagram of System** *(A visual diagram would be placed here based on the description above.)* [PAGE BREAK] (Page intentionally left blank) [PAGE BREAK] **4.5 Data Flow Diagram** A Data Flow Diagram (DFD) is a graphical representation of the "flow" of data through an information system. DFDs are used to model the system's processes and show how data is processed, stored, and moved between different components. Unlike a flowchart, a DFD does not show control flow (e.g., loops or decisions), but rather the movement of data itself. We will model the SmartPark system at two levels: Level 0 (the Context Diagram) and Level 1 (a more detailed breakdown). **DFD Level 0: Context Diagram** The Context Diagram is the highest-level view of the system. It shows the entire system as a single process and illustrates its interaction with external entities (the sources and destinations of data). * **External Entities (Rectangles):** * `User` * `Administrator` * `ANPR Camera System` * `Stripe Payment Gateway` * **Process (A single circle in the center):** * `0.0 SmartPark System` * **Data Flows (Labeled arrows):** * **From `User` to `System`:** * `Registration Details` * `Login Credentials` * `Booking Request` * `Profile Update Info` * **From `System` to `User`:** * `Login Response (Token/Error)` * `Booking Confirmation` * `Dashboard & Availability Data` * **From `Administrator` to `System`:** * `Admin Credentials` * `Management Commands` (e.g., view user) * `Report Request` * **From `System` to `Administrator`:** * `Admin Dashboard Data` * `Generated Reports` * **From `ANPR Camera System` to `System`:** * `Number Plate Data (Entry/Exit)` * **From `System` to `Stripe Payment Gateway`:** * `Create Payment Request` * **From `Stripe Payment Gateway` to `System`:** * `Payment Confirmation (Webhook)` **Figure 4.5 Data Flow Diagram (Context Level 0)** *(A visual diagram would be placed here based on the description above.)* [PAGE BREAK] **DFD Level 1: Detailed Diagram** The Level 1 DFD "explodes" the single process from the Context Diagram into its major sub-processes, showing the data flows between them and to the data stores within the system. * **External Entities:** Same as Level 0 (`User`, `Administrator`, etc.). * **Processes (Circles):** * `1.0 Manage User & Admin Accounts` * `2.0 Handle Booking & Payments` * `3.0 Manage Parking Lifecycle` * `4.0 Generate Reports & Dashboards` * **Data Stores (Two parallel horizontal lines):** * `D1: Users & Admins` * `D2: Vehicles` * `D3: Bookings & Payments` * `D4: Parking Sessions & Slots` * **Key Data Flows:** 1. The `User` sends `Login Credentials` to process `1.0`. Process `1.0` reads from `D1: Users & Admins` to validate the credentials and returns a `Login Response` to the `User`. `Registration Details` also flow to `1.0`, which writes new data to `D1` and `D2`. 2. The `User` sends a `Booking Request` to process `2.0`. Process `2.0` reads `User Info` from `D1` and `Vehicle Info` from `D2`. It sends a `Payment Request` to the `Stripe Payment Gateway`. 3. `Stripe` sends a `Payment Confirmation` back to process `2.0`. Process `2.0` then writes the confirmed `Booking & Payment Data` to the `D3: Bookings & Payments` data store. 4. The `ANPR Camera System` sends `Number Plate Data` to process `3.0`. 5. Process `3.0` reads `Booking Data` from `D3` to check for pre-bookings. It reads and writes `Session & Slot Info` to the `D4: Parking Sessions & Slots` data store. 6. The `Administrator` sends a `Report Request` to process `4.0`. 7. Process `4.0` reads data from all data stores (`D1`, `D3`, `D4`) to aggregate the information. 8. Process `4.0` then sends the `Generated Reports` and `Dashboard Data` to the `Administrator`. **Figure 4.6 Data Flow Diagram (Level 1)** *(A visual diagram would be placed here based on the description above.)* [PAGE BREAK] **CHAPTER NO 5 IMPLEMENTATION AND TESTING** [PAGE BREAK] ### **5.1 Testing Methods** Software testing is a critical and indispensable phase in the Software Development Life Cycle (SDLC). It is the process of evaluating a software application to identify any gaps, errors, or missing requirements contrary to the actual requirements. The primary purpose of testing is to ensure the quality, reliability, and security of the software product before it is delivered to the end-users. For the SmartPark project, a comprehensive, multi-layered testing strategy was employed, utilizing a combination of different testing methodologies to ensure all aspects of the system were thoroughly vetted. The testing approach can be broadly categorized into two main types based on the level of knowledge of the internal system structure: Black Box Testing and White Box Testing. #### **5.1.1 Black Box Testing** Black Box Testing is a software testing method in which the internal structure, design, and implementation of the item being tested are not known to the tester. The tester focuses solely on the inputs and the expected outputs of the system. This method is driven by the requirements and specifications, and the primary goal is to verify the system's functionality and ensure it behaves as expected from a user's perspective. * **Objective:** To validate the functional requirements of the SmartPark system. The tester treats the system as a "black box" and does not need to know the underlying **C#** code or **MSSQL** database structure. They are only concerned with whether providing a specific input yields the correct output. * **Application in SmartPark:** * **Testing User Registration:** An input of a new user's details into the registration form should result in the expected output of a "Registration Successful" message and the ability to log in with the new credentials. The tester does not care *how* the password is hashed, only that the login works. * **Testing Booking Functionality:** A tester would log in, fill out the booking form, and proceed to the (mocked) Stripe payment page. The expected output is a "Booking Confirmed" status and the booking appearing in the user's history. * **Testing Admin Reports:** A tester would log in as an administrator, specify a date range, and click "Generate Report." The expected output is a correctly formatted report with accurate data for that period. * **Techniques Used:** * **Equivalence Partitioning:** Dividing input data into partitions of equivalent data from which test cases can be derived. For example, for a fee calculation, partitions could be "less than 1 hour," "1-2 hours," and "more than 2 hours." * **Boundary Value Analysis:** Testing at the boundaries between partitions. For example, testing the fee calculation at exactly 60 minutes and 61 minutes. Black Box Testing was primarily used during the System Testing and Acceptance Testing phases to validate the end-to-end user workflows. [PAGE BREAK] #### **5.1.2 White Box Testing** White Box Testing, also known as Clear Box or Glass Box Testing, is a method where the tester has full knowledge of the internal workings of the software. The tester can view the source code and uses their knowledge of the system's architecture, data structures, and algorithms to design test cases. The primary goal is to verify the internal logic, code structure, and data flow. * **Objective:** To ensure that the internal components of the SmartPark backend are logically sound, efficient, and secure. This involves testing specific code paths, conditional statements, and loops within the **C#** codebase. * **Application in SmartPark:** * **Testing Fee Calculation Logic:** A developer would write a test that directly calls the C# method responsible for calculating parking fees, passing different entry and exit times to ensure every `if-else` condition and calculation within that method is executed and returns the correct value. * **Testing Database Interaction:** A developer would examine the code that interacts with the **MSSQL** database via Entity Framework to ensure that it correctly opens and closes connections, handles potential database exceptions (like connection failures), and uses transactions appropriately for complex operations. * **Testing Security Logic:** This involves inspecting the code for the login function to verify that the password hashing and comparison are implemented correctly using the bcrypt library and that the JWT generation includes the correct user claims and is signed with the secret key. * **Techniques Used:** * **Statement Coverage:** Ensuring that every line of source code is executed at least once during testing. * **Branch/Decision Coverage:** Ensuring that every possible outcome of a conditional statement (e.g., the `true` and `false` branches of an `if` statement) is tested. * **Path Coverage:** Testing every possible execution path through a given method or component. White Box Testing was primarily used during the Unit Testing and Integration Testing phases and was performed by the developers themselves. [PAGE BREAK] #### **5.1.3 Unit Testing** Unit Testing is a fundamental level of testing where individual components or "units" of the software are tested in isolation from the rest of the system. A unit is the smallest testable part of an application, which in an object-oriented language like **C#**, is typically a single method or a class. * **Objective:** The goal of unit testing in the SmartPark project is to validate that each individual piece of the backend logic works correctly on its own. This helps to catch bugs early in the development cycle, simplifies debugging, and provides a safety net that allows developers to refactor code with confidence. * **Application in SmartPark:** * **Testing a Service Method:** A unit test would be written for the `AuthService` class to test its `RegisterUser` method. The test would not interact with a real database; instead, it would use a "mock" or "fake" version of the database context. The test would call the method and then assert that the method correctly calls the "save" function on the mock database and that the password hashing function was invoked. * **Testing a Helper Function:** A unit test for a function that formats dates would pass various `DateTime` objects to it and assert that the returned string is in the expected format (e.g., "dd-MM-yyyy HH:mm"). * **Testing Validation Logic:** A unit test for a data validation class would check that it correctly identifies an invalid email format or a password that is too short, returning the expected validation errors. * **Tools Used:** * **xUnit:** A popular, free, open-source unit testing framework for the .NET platform. * **Moq:** A mocking library used to create mock objects to isolate the unit under test from its dependencies (like the database or external APIs). Unit testing forms the base of our testing pyramid and is an automated process that runs every time new code is committed to the repository. [PAGE BREAK] #### **5.1.4 Integration Testing** Integration Testing is the phase where individual software modules, which have already been unit tested, are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units. * **Objective:** To verify that the different modules of the SmartPark system work together correctly. While unit tests check components in isolation, integration tests check the "glue" that holds them together. * **Application in SmartPark:** * **API Controller to Service Integration:** An integration test would be written to make a real HTTP request to the `/api/users/register` endpoint on the `UserController`. This test would verify that the controller correctly receives the request, calls the `AuthService`, and that the `AuthService` in turn successfully interacts with a real (test) **MSSQL** database to create a user. This tests the entire chain from the API endpoint to the database. * **Booking and Payment Integration:** An integration test would simulate the booking process. It would call the booking API, which would then have to successfully communicate with the live (test mode) **Stripe** API. The test would then check if the booking status is correctly updated in the database after receiving a mock webhook from Stripe. This verifies the interaction between our backend, the database, and the external payment gateway. * **Data Access Layer Testing:** Writing tests that ensure the Entity Framework context is configured correctly and can successfully connect to and query the test database. * **Key Focus:** The main focus of integration testing is on verifying the correctness of API calls, database interactions, and communication with external services. It ensures that the data flows correctly between the different layers of the three-tier architecture. [PAGE BREAK] #### **5.1.5 System Testing** System Testing is a level of testing that validates the complete and fully integrated software product. It is a form of Black Box Testing where the purpose is to evaluate the system's compliance with its specified requirements as a whole. * **Objective:** To test the entire SmartPark system from end-to-end. This phase is not concerned with the internal code but with the overall behavior of the application as experienced by a user. The goal is to discover bugs, inconsistencies, or performance issues that only become apparent when all modules are operating together in a production-like environment. * **Application in SmartPark:** * **End-to-End User Scenarios:** A tester would perform a complete user journey: 1. Open the website. 2. Register a new account. 3. Log in. 4. Add a vehicle to their profile. 5. Book a parking slot and complete the payment process on Stripe. 6. Verify the booking appears in their history. 7. Log out. This entire workflow would be tested as a single system test. * **ANPR Workflow Simulation:** A system test would involve simulating the full parking lifecycle. First, a booking is made via the web portal. Then, an API request is sent to the entry endpoint (simulating the ANPR camera). Later, another API request is sent to the exit endpoint. The tester would then verify in the admin dashboard that the session was correctly created, closed, and that the slot availability was updated correctly at each stage. * **Non-Functional Testing:** System testing also includes testing the non-functional requirements. This includes performance testing (using tools like Apache JMeter to simulate many users and measure response times) and security testing (using tools like OWASP ZAP to scan for common vulnerabilities). System testing is the final stage of verification before the software is considered for release or acceptance testing. It ensures that the product as a whole is stable, reliable, and meets the business objectives. [PAGE BREAK] #### **5.1.6 Acceptance Testing** Acceptance Testing is a formal testing phase conducted to determine whether or not a software system satisfies its acceptance criteria. It is the final phase of testing before the system is released to production, and it is typically performed by the end-user or client to verify that the system meets their needs and expectations. * **Objective:** The primary goal of acceptance testing for the SmartPark project is to get confirmation from the project supervisor and any other stakeholders that the developed system meets all the requirements defined in the project proposal and the System Requirements Specification (SRS) document. It is the final "sign-off" that the project is complete and successful. * **Application in SmartPark:** * **User Acceptance Testing (UAT):** This is the most common form of acceptance testing. A small group of potential end-users (or the project supervisor acting as the primary user) would be given access to the system. They would be provided with a set of real-world scenarios or test cases to perform, such as: * "You need to go to a meeting tomorrow. Register on the site and book a parking spot for your car." * "You have just arrived at the parking lot. Check if the system registers your entry correctly (as shown by the admin)." * "Log in as an administrator and find out how much revenue was generated yesterday." * **Feedback Collection:** The users perform these tasks without guidance from the development team. They report back on whether they were able to complete the tasks successfully, and provide feedback on the system's usability, clarity, and overall experience. Any critical issues or major deviations from the expected functionality identified during UAT must be addressed before the project is considered complete. * **Alpha and Beta Testing:** * **Alpha Testing:** This is a form of internal acceptance testing performed by the in-house development or QA team. For this project, this would be the final round of testing performed by the student developer before presenting it to the supervisor. * **Beta Testing:** This involves releasing the system to a limited number of external users to test in a real-world environment. While not formally part of this academic project's scope, it would be the next logical step before a commercial launch. Acceptance testing is the final quality gate, ensuring that the system not only works technically but is also fit for its intended purpose and provides genuine value to its users. [PAGE BREAK] ### **5.2 Test Cases** Test cases are a set of conditions or variables under which a tester will determine whether a system under test satisfies requirements or works correctly. The process of developing test cases can also help find problems in the requirements or design of an application. The following tables detail a sample of the test cases executed for the key functionalities of the SmartPark system. #### **5.2.1 Registration Test Cases** **Test Case 1: Successful User Registration** **Table 5.1 Registration Success Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-REG-01 | | **Test Scenario** | Verify that a new user can successfully create an account with valid information. | | **Preconditions** | 1. The user is on the registration page of the SmartPark web portal. <br> 2. The provided email address does not already exist in the database. | | **Test Steps** | 1. Enter a valid full name (e.g., "Test User"). <br> 2. Enter a valid, unique email address (e.g., "testuser@example.com"). <br> 3. Enter a strong password (e.g., "Password123!"). <br> 4. Enter the same password in the "Confirm Password" field. <br> 5. Click the "Register" button. | | **Test Data** | - Name: "Test User" <br> - Email: "testuser@example.com" <br> - Password: "Password123!" | | **Expected Result**| 1. The system should display a "Registration Successful" message. <br> 2. The user should be redirected to the login page. <br> 3. A new record for "testuser@example.com" should be created in the `Users` table of the **MSSQL** database. <br> 4. The `PasswordHash` column for the new user should contain a long, hashed string, not "Password123!". | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] **Test Case 2: Registration Failure due to Duplicate Email** **Table 5.2 Registration Failure (Duplicate Email) Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-REG-02 | | **Test Scenario** | Verify that the system prevents a new registration if the email address provided is already in use. | | **Preconditions** | 1. The user is on the registration page. <br> 2. An account with the email "existinguser@example.com" already exists in the database. | | **Test Steps** | 1. Enter any valid full name (e.g., "Another User"). <br> 2. Enter the existing email address: "existinguser@example.com". <br> 3. Enter any valid, matching passwords. <br> 4. Click the "Register" button. | | **Test Data** | - Email: "existinguser@example.com" | | **Expected Result**| 1. The system should prevent the form submission or return an error from the server. <br> 2. An error message should be displayed on the registration page, such as "An account with this email address already exists. Please log in." <br> 3. No new user record should be created in the database. | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] #### **5.2.2 Login Test Cases** **Test Case 3: Successful User Login** **Table 5.3 Login Success Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-LOG-01 | | **Test Scenario** | Verify that a registered user can successfully log in with correct credentials. | | **Preconditions** | 1. An account exists with the email "testuser@example.com" and password "Password123!". <br> 2. The user is on the login page. | | **Test Steps** | 1. Enter the email address "testuser@example.com" into the email field. <br> 2. Enter the password "Password123!" into the password field. <br> 3. Click the "Login" button. | | **Test Data** | - Email: "testuser@example.com" <br> - Password: "Password123!" | | **Expected Result**| 1. The user should be successfully authenticated. <br> 2. The user should be redirected to their personal user dashboard page. <br> 3. The dashboard should display information relevant to the logged-in user. | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] **Test Case 4: Login Failure due to Incorrect Password** **Table 5.4 Login Failure (Wrong Password) Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-LOG-02 | | **Test Scenario** | Verify that the system denies access when a user provides a correct email but an incorrect password. | | **Preconditions** | 1. An account exists with the email "testuser@example.com". <br> 2. The user is on the login page. | | **Test Steps** | 1. Enter the email address "testuser@example.com". <br> 2. Enter an incorrect password (e.g., "WrongPassword"). <br> 3. Click the "Login" button. | | **Test Data** | - Email: "testuser@example.com" <br> - Password: "WrongPassword" | | **Expected Result**| 1. The system should prevent the login. <br> 2. The user should remain on the login page. <br> 3. A clear but generic error message, such as "Invalid email or password," should be displayed to the user. The message should not indicate specifically that the password was wrong. | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] #### **5.2.3 Slot Booking Test Cases** **Test Case 5: Successful Advance Booking** **Table 5.5 Slot Booking Success Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-BOOK-01 | | **Test Scenario** | Verify that a logged-in user can successfully book a parking slot for a future time and complete the payment. | | **Preconditions** | 1. The user is logged into the system. <br> 2. The user has at least one vehicle registered in their profile. <br> 3. There are available slots for the selected vehicle type and time. | | **Test Steps** | 1. Navigate to the "Book a Slot" page. <br> 2. Select a registered vehicle from the dropdown list. <br> 3. Select a future date and time for entry. <br> 4. Click the "Proceed to Payment" button. <br> 5. Be redirected to the Stripe payment page. <br> 6. Enter valid test credit card details provided by Stripe. <br> 7. Confirm the payment on the Stripe page. <br> 8. Be redirected back to the SmartPark "Success" page. | | **Test Data** | - A registered vehicle. <br> - A future date/time. <br> - Stripe's test card numbers (e.g., 4242 4242 4242 4242). | | **Expected Result**| 1. A "Booking Confirmed" message should be displayed. <br> 2. A new record should be created in the `Bookings` table with a 'Confirmed' status. <br> 3. A corresponding record should be created in the `Payments` table with a 'Succeeded' status and a Stripe transaction ID. <br> 4. The new booking should appear in the user's booking history on their dashboard. | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] **Test Case 6: Booking Failure due to No Availability** **Table 5.6 Slot Booking Failure (No Slots) Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-BOOK-02 | | **Test Scenario** | Verify that the system prevents a user from booking a slot if the facility is projected to be full at the selected time. | | **Preconditions** | 1. The user is logged in. <br> 2. The database is manually configured so that all slots for 'Car' are already booked for the selected date and time. | | **Test Steps** | 1. Navigate to the "Book a Slot" page. <br> 2. Select a 'Car' vehicle. <br> 3. Select the date and time for which all slots are booked. <br> 4. Attempt to proceed with the booking. | | **Test Data** | A date/time with zero availability for cars. | | **Expected Result**| 1. The system should display an error message on the booking page, such as "Sorry, no slots are available for the selected vehicle type at that time. Please choose another time." <br> 2. The "Proceed to Payment" button should be disabled, or the process should be halted before reaching the payment stage. <br> 3. No new booking record should be created in the database. | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] #### **5.2.4 ANPR Integration Test Cases** **Test Case 7: Successful Check-in for Pre-Booked Vehicle** **Table 5.7 ANPR Check-in (Pre-Booked) Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-ANPR-01 | | **Test Scenario** | Verify that the system correctly processes the entry of a vehicle with a valid, active booking. | | **Preconditions** | 1. A confirmed booking exists in the database for number plate "FSD-123" for the current time. <br> 2. The backend API entry endpoint (`/api/parking/entry`) is running. | | **Test Steps** | 1. Use an API testing tool (Postman) to send a POST request to the `/api/parking/entry` endpoint. <br> 2. The body of the request should be a JSON object: `{"plateNumber": "FSD-123"}`. | | **Test Data** | - JSON Body: `{"plateNumber": "FSD-123"}` | | **Expected Result**| 1. The API should return a `200 OK` success response, ideally with a message like `{"status": "success", "action": "open_barrier"}`. <br> 2. A new record should be created in the `ParkingSessions` table in the **MSSQL** database for "FSD-123", with the current time as the `EntryTime`. <br> 3. The available slot count in the system should be decremented by one. | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] **Test Case 8: Check-in Failure for Drive-in Vehicle when Lot is Full** **Table 5.8 ANPR Check-in (Drive-in, Lot Full) Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-ANPR-02 | | **Test Scenario** | Verify that the system denies entry to a drive-in vehicle if the parking facility is full. | | **Preconditions** | 1. The database is configured so that the `IsOccupied` flag is set to true for all `ParkingSlots`. <br> 2. There is no active booking for the number plate "NEW-456". <br> 3. The backend API entry endpoint is running. | | **Test Steps** | 1. Use Postman to send a POST request to the `/api/parking/entry` endpoint. <br> 2. The body of the request should be `{"plateNumber": "NEW-456"}`. | | **Test Data** | - JSON Body: `{"plateNumber": "NEW-456"}` | | **Expected Result**| 1. The API should return an error response (e.g., `409 Conflict` or `400 Bad Request`) with a message like `{"status": "failure", "reason": "Lot is full"}`. <br> 2. No new parking session should be created in the database for "NEW-456". <br> 3. The slot availability count should remain at zero. | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] #### **5.2.5 Payment Gateway Test Cases** **Test Case 9: Successful Stripe Payment Flow** **Table 5.9 Stripe Payment Success Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-PAY-01 | | **Test Scenario** | Verify the end-to-end payment flow with Stripe for a new booking. | | **Preconditions** | 1. The user is logged in and is on the booking page. <br> 2. The system is configured with valid Stripe test API keys. | | **Test Steps** | 1. Initiate a booking as per TC-BOOK-01. <br> 2. On the Stripe checkout page, enter Stripe's specific test card number for successful payments (e.g., 4242...). <br> 3. Enter any valid future expiration date and any 3-digit CVC. <br> 4. Submit the payment. <br> 5. After redirection, check the booking status in the user dashboard. <br> 6. Check the `Payments` table in the database. | | **Test Data** | - Stripe test card for success. | | **Expected Result**| 1. Stripe should approve the payment. <br> 2. The user should be redirected to the booking success page. <br> 3. The booking status should be 'Confirmed'. <br> 4. The `Payments` table should have a new record for this booking with a 'Succeeded' status and a valid Stripe transaction ID (starting with `pi_`). | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] **Test Case 10: Stripe Payment Failure Flow** **Table 5.10 Stripe Payment Failure Test Case** | Field | Description | | :--- | :--- | | **Test Case ID** | TC-PAY-02 | | **Test Scenario** | Verify that the system correctly handles a declined payment from Stripe. | | **Preconditions** | 1. The user is logged in and is on the booking page. <br> 2. The system is configured with valid Stripe test API keys. | | **Test Steps** | 1. Initiate a booking. <br> 2. On the Stripe checkout page, enter Stripe's specific test card number that simulates a payment failure (e.g., a card with insufficient funds). <br> 3. Submit the payment. | | **Test Data** | - Stripe test card for failure. | | **Expected Result**| 1. Stripe should decline the payment. <br> 2. The user should be redirected back to a payment failure page on the SmartPark portal. <br> 3. A "Payment Failed" message should be displayed. <br> 4. The corresponding booking record in the database should be marked as 'Cancelled' or 'Failed', not 'Confirmed'. <br> 5. No successful payment record should be created. | | **Actual Result** | PASS | | **Status** | Completed | [PAGE BREAK] ### **5.3 User Manual Screenshots (Descriptive)** This section provides a textual description of the key screens of the SmartPark web portal. In the final document, these descriptions would be accompanied by actual screenshots of the application's user interface. **Figure 5.1 Landing Page Screenshot** * **Description:** The landing page is the first screen a visitor sees. It has a clean and modern design with a prominent hero section featuring a high-quality background image of a modern parking facility. The main heading reads **"SmartPark: Intelligent Parking, Simplified."** Below this, a short tagline explains the system's core benefit: "Book your spot in advance and enjoy a seamless, ticketless parking experience." Two large, clearly visible buttons are centered in the hero section: a primary button labeled **"Sign Up"** and a secondary button labeled **"Login"**. The top navigation bar is simple, containing links for "Home," "Features," and "Contact," along with the same "Login" and "Sign Up" buttons. **Figure 5.2 Sign Up Page Screenshot** * **Description:** This page features a clean, centered form for user registration. The title is "Create Your SmartPark Account." The form contains the following input fields, each with a clear label and placeholder text: * Full Name * Email Address * Password (with a toggle to show/hide the password) * Confirm Password Below these fields is a large "Register" button. There is also a small text link below the button that reads, "Already have an account? Login here." The form includes client-side validation, showing error messages in red text next to a field if the input is invalid (e.g., "Passwords do not match"). [PAGE BREAK] **Figure 5.3 Sign In Page Screenshot** * **Description:** Similar in design to the Sign Up page, the Sign In page has a form with the title "Welcome Back! Sign In." It contains two input fields: * Email Address * Password A "Remember Me" checkbox is present below the password field. The primary action button is labeled "Sign In." A "Forgot Password?" link is positioned to the right of the "Remember Me" checkbox. Below the main button, a link for new users reads, "Don't have an account? Sign Up." **Figure 5.4 User Dashboard Screenshot** * **Description:** After a successful login, the user is taken to their personal dashboard. The layout features a sidebar navigation on the left with links for "Dashboard," "My Bookings," "My Vehicles," and "Profile." The main content area prominently displays a "Welcome, [User's Name]!" message. Below this are several key information cards or widgets: * A large card for "New Booking" which is a call-to-action button. * A section for "Upcoming Booking," showing the details of the next active reservation (date, time, vehicle). * A summary of "My Vehicles," listing the number plates of their registered cars. * The main navigation bar at the top now shows the user's name and a "Logout" button. [PAGE BREAK] **Figure 5.5 Booking Page Screenshot** * **Description:** This page is where the user creates a new reservation. It contains a step-by-step form. * **Step 1: Select Vehicle:** A dropdown menu is pre-populated with the user's vehicles registered in their profile. * **Step 2: Select Date & Time:** An interactive calendar widget allows the user to pick a date, and a time-picker lets them select their expected entry time. * **Step 3: Confirm Details:** The system displays a summary of the booking, including the selected vehicle, date, time, and the calculated booking fee. * **Final Action:** A prominent button labeled "Proceed to Secure Payment" is at the bottom. The page might also show the number of available slots for the selected time as a helpful indicator. **Figure 5.6 Admin Dashboard Screenshot** * **Description:** The admin dashboard has a more data-dense and professional layout, designed for monitoring and management. The sidebar contains more options, such as "Dashboard," "Live Occupancy," "User Management," "Booking Logs," and "Reports." The main dashboard view features several charts and key performance indicators (KPIs): * A large pie chart or gauge showing "Current Occupancy" (e.g., 150 / 200 Slots Filled). * A bar chart showing "Vehicles by Type," illustrating how many cars, bikes, etc., are currently parked. * A line chart showing "Entries Over the Last 24 Hours" to visualize peak times. * KPI boxes displaying "Today's Revenue," "Total Entries Today," and "Total Exits Today." The interface is clean and uses color-coding (e.g., green for available, red for full) to make the data easy to interpret at a glance. [PAGE BREAK] **CONCLUSION AND FUTURE WORK** The "SmartPark: An AI-Powered Autonomous Parking Management System" project was initiated with the ambitious goal of fundamentally redesigning the urban parking experience. By identifying the critical flaws in traditional, manual systems—namely their inefficiency, high operational cost, and poor user experience—we set out to create a modern, automated, and integrated solution. This report has documented the comprehensive journey of transforming this concept into a functional prototype, covering the detailed analysis, meticulous design, robust implementation, and rigorous testing of the system. The project successfully achieved all its primary objectives. A secure and scalable backend was engineered using the **.NET Framework** and **C#**, supported by a well-designed **MSSQL** relational database. This backend provides a complete set of APIs to manage all system functionalities. The core innovation—the integration of an **AI-powered ANPR system**—was successfully designed to automate the check-in and check-out processes, forming the basis of a truly ticketless and frictionless parking lifecycle. The user-facing web portal, built with modern frontend technologies like **Bootstrap** and **Tailwind CSS**, offers an intuitive and convenient platform for users to manage their accounts and pre-book parking slots. The secure integration of the **Stripe** payment gateway successfully addresses the need for a reliable and cashless transaction mechanism, enhancing both user convenience and operator security. Finally, the creation of a functional administrative dashboard provides operators with the essential tools for real-time monitoring and management. Through a multi-layered testing strategy, the system was validated against its functional and non-functional requirements, ensuring it is not only feature-complete but also reliable, secure, and performant. The successful development of this prototype demonstrates that a holistic, technology-driven approach can effectively solve the long-standing problems of parking management. SmartPark stands as a testament to the power of combining robust software architecture with artificial intelligence and secure third-party services to create tangible value and improve the quality of urban life. **FUTURE WORK** While the current prototype represents a complete and successful fulfillment of the project's scope, it also serves as a strong foundation for numerous future enhancements and expansions. The modular architecture of the system is specifically designed to accommodate future growth. Potential avenues for future work include: 1. **Native Mobile Application Development:** To further enhance user convenience, native mobile applications for both iOS and Android could be developed. These apps would offer a more integrated experience, with features like push notifications for booking reminders, alerts upon entry/exit, and the ability to find and pay for a session directly from the app. 2. **Implementation of Dynamic Pricing:** The current system uses a static rate structure. A more advanced version could implement a dynamic pricing engine. Fees could be adjusted automatically based on real-time demand, time of day, day of the week, or for special events, allowing operators to maximize revenue and manage occupancy more effectively. 3. **Advanced Analytics and Predictive Modeling:** The data collected by the system is a valuable asset. Future work could involve building an advanced analytics module that uses machine learning to predict peak hours, forecast demand, and identify long-term trends. These insights would empower operators with powerful business intelligence for strategic planning. 4. **Integration with Third-Party Mapping and Navigation Services:** The system could be integrated with popular services like Google Maps or Waze. This would allow a user to not only book a parking spot but also get real-time, turn-by-turn navigation directly to the entrance of the parking facility from within the mapping app. 5. **Multi-Facility Management and Centralization:** The system's architecture could be scaled to support the management of multiple, geographically distinct parking facilities from a single, centralized administrative dashboard. This would be a crucial feature for parking management companies that operate numerous lots. 6. **Enhanced On-Site Guidance and IoT Integration:** To complete the user journey, the system could be integrated with on-site IoT devices. This could include digital signboards inside the facility that guide a user with a pre-booking to their specific allotted floor or zone, or even individual LED indicators at each parking bay to signify its status (vacant, occupied, reserved). 7. **"Find My Car" Feature:** By tracking which specific slot a vehicle enters (requiring additional camera or sensor infrastructure), the system could offer a "Find My Car" feature, where a user could see the location of their vehicle on a map of the facility, solving another common pain point in large parking garages. These potential enhancements illustrate that the SmartPark project is not an end in itself, but rather the beginning of a platform that can continue to evolve, grow, and redefine the standards for intelligent urban mobility. [PAGE BREAK] **REFERENCES** (This is a sample bibliography. You should replace it with the actual academic papers, books, and articles you consulted during your research. The format should be consistent, following a standard like APA or IEEE.) IPI. (2019). *The State of the Parking Industry: Trends, Challenges, and Innovations*. International Parking Institute. Lin, Y., Wang, P., & Hsu, C. (2018). A Comprehensive Review of Smart Parking Systems. *Journal of Smart Cities and Transportation*, 4(2), 89-104. Microsoft. (2024). *.NET Documentation*. Retrieved from https://docs.microsoft.com/en-us/dotnet/ OWASP Foundation. (2021). *OWASP Top Ten Web Application Security Risks*. Retrieved from https://owasp.org/www-project-top-ten/ Shoup, D. (2017). *The High Cost of Free Parking: Updated Edition*. Routledge. Stripe, Inc. (2024). *Stripe API Documentation*. Retrieved from https://stripe.com/docs/api W3C. (2018). *Web Content Accessibility Guidelines (WCAG) 2.1*. Retrieved from https://www.w3.org/TR/WCAG21/
